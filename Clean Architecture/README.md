# Clean Architecture
## 1부 소개
### 1장 설계와 아키텍처란?
- 설계(design)와 아키텍처(architecture)가 무엇인가?
	- 아키텍처는 저수준의 세부사항과는 분리된 고수준의 무언가를 가리킬 때 흔히 사용
	- 설계는 저수준의 구조 또는 결정사항 등을 의미할 때가 많다.
	- 하지만 아키텍트가 실제로 하는 일을 살펴보면 이러한 구분은 무의미
- 이러한 의사결정의 목표는?
	- 소프트웨어 아키텍처의 목표는 필요한 시스템을 만들고 유지보수하는 데 투입되는 인력을 최소화하는 데 있다.
- 결론
	- 개발 조직이 할 수 있는 최고의 선택지는 조직에 스며든 과신을 인지하여 방지하고, 소프트웨어 아키텍처의 품질을 심각하게 고민하기 시작하는 것이다.

### 2장 두 가지 가치에 대한 이야기
- 모든 소프트웨어 시스템은 이해관계자에게 행위(behavior), 구조(structure) 두 가지 가치를 제공한다. 두 가치를 모두 반드시 높게 유지해야 한다.
- 행위
	- 프로그래머를 고용하는 이유는 이해관계자를 위해 기계가 수익을 창출하거나 비용을 절약하도록 만들기 위해서다.
	- 이를 위해 프로그래머는 이해관계자가 기능 명세서나 요구사항문서를 구체화할 수 있도록 돕는다. 그리고 이해관계자의 기계가 이러한 요구사항을 만족하도록 코드를 작성한다.
	- 기계가 이러한 요구사항을 위반하면, 프로그래머는 디버거를 열고 문제를 고친다.
	- 많은 프로그래머가 이러한 활동이 자신이 해야 할 일의 전부라고 생각한다.
- 아키텍처
	- 소프트웨어는 반드시 부드러워야 한다.(변경사항을 간단하고 쉽게 적용할 수 있어야 한다.)
	- 아키텍처가 특정 형태를 다른 형태보다 선호하면 할수록, 새로운 기능을 이 구조에 맞추는 게 더 힘들어진다.
	- 따라서 아키텍처는 형태에 독립적이어야 하고, 그럴수록 더 실용적이다.
- 아이젠하워 매트릭스
	1. 긴급하고 중요한
	2. 긴급하지는 않지만 중요한
	3. 긴급하지만 중요하지 않은
	4. 긴급하지도 중요하지도 않은
	- 아키텍처, 즉 중요한 일은 이 항목의 가장 높은 두 순위를 차지하지만, 행위는 첫 번째와 세 번째에 위치한다.
	- 업무 관리자와 개발자가 흔하게 저지르는 실수는 세 번째에 위치한 항목을 첫 번째로 격상시켜 버리는 일이다. 이러한 실수로 인해 시스템에서 중요도가 높은 아키텍처를 무시한 채 중요도가 떨어지는 기능을 선택하게 된다.
- 아키텍처를 위해 투쟁하라
	- 개발팀은 회사에서 가장 중요하다고 스스로 믿는 가치를 위해 투쟁해야 한다.
	- 아키텍처가 후순위가 되면 시스템을 개발하는 비용이 더 많이 들고, 일부 또는 전체 시스템에 변경을 가하는 일이 현실적으로 불가능해진다.

## 2부 벽돌부터 시작하기: 프로그래밍 패러다임
### 3장 패러다임 개요
- 이 장에서는 세가지 패러다임인 구조적 프로그래밍, 객체지향 프로그래밍, 함수형 프로그래밍에 대해 설명한다.
- 구조적 프로그래밍
	- 최초로 적용된 패러다임
	- Dijkstra는 무분별한 점프(goto 문장)는 프로그램 구조에 해롭다는 사실을 제시했다.
	- Dijkstra는 이러한 점프들을 if/then/else, do/while/until과 같이 더 익숙한 구조로 대체했다.
	- 요약
		- 구조적 프로그래밍은 제어흐름에 직접적인 전환에 대해 규칙을 부과한다.
- 객체 지향 프로그래밍
	- 두번째로 도입된 패러다임
	- 요한 달과 크리스텐 니가드는 알골(ALGOL) 언어의 함수 호출 스택 프레임을 힙으로 옮기면, 함수 호출이 반환된 이후에도 함수에서 선언된 지역 변수가 오랫동안 유지될 수 있음을 발견했다. 이러한 함수가 클래스의 생성자가 되었고, 지역 변수는 인스턴스 변수, 중첩 함수는 메서드가 되었다.
	- 요약
		- 객체 지향 프로그래밍은 제어흐름의 간접적인 전환에 대해 규칙을 부과한다.
- 함수형 프로그래밍
	- 세 번째 패러다임은 최근에 들어서야 겨우 도입되기 시작했지만, 세 패러다임중 가장 먼저 만들어졌다.
	- 함수형 프로그래밍은 람다 계산법의 연구 결과에 직접적인 영향을 받아 만들어졌다.
	- 람다 계산법의 기초가 되는 개념은 불변성으로, 심볼의 값이 변경되지 않는다는 개념이다.
	- 요약
		- 함수형 프로그래밍은 할당문에 대해 규칙을 부과한다.
- 생각할 거리
	- 각 패러다임은 프로그래머에게서 권한을 박탈한다.
	- 어느 패러다임도 새로운 권한을 부여하지 않는다.
	- 즉 무엇을 해서는 안 되는지를 말해준다.
	- 이 패러다임들은 1958년~1968년에 걸쳐서 만들어졌고, 이후 새롭게 등장한 패러다임은 없다.
- 결론
	- 세 가지 패러다임과 아키텍처의 세 가지 큰 관심사(함수, 컴포넌트 분리, 데이터 관리)가 어떻게 서로 연관되는지에 주목하자.

### 4장 구조적 프로그래밍
- 다익스트라는 프로그램을 순차, 분기, 반복이라는 세가지 구조만으로 표현할 수 있다는 사실을 증명했다.
- 다익스트라가 "goto문의 해로움"이라는 편지를 보냈고, 승리했다.
- 테스트
	- 다익스트라는 "테스트는 버그가 있음을 보여줄뿐, 버그가 없음을 보여줄 수는 없다"라고 말한 적이 있다.
	- 다시 말해 프로그램이 잘못되었음을 테스트를 통해 증명할 수는 있지만, 프로그램이 맞다고 증명할 수는 없다.
	- 이 사실은 소프트웨어 개발이 수학적인 구조를 다루는 듯 보이더라도, 수학적인 시도가 아니라는 사실을 담고 있다.
	- 제약 없는 goto문을 사용하는 등의 이유로 입증이 불가능한 프로그램은 테스트를 아무리 많이 수행하더라도 절대로 올바르다고 볼 수 없다.
- 결론
	- 구조적 프로그래밍이 오늘날까지 가치 있는 이유는 프로그래밍에서 반증 가능한 단위를 만들어 낼 수 있는 바로 이 능력 때문이다. 또한 흔히 현대적 언어가 아무런 제약없는 goto 문장은 지원하지 않는 이유이기도 하다. 뿐만 아니라 아키텍처 관점에서는 기능적 분해를 최고의 실천법 중 하나로 여기는 이유이기도 하다.

### 5장 객체 지향 프로그래밍
- 캡슐화?
	- C언어에서도 완벽한 캡슐화가 가능하다.
	- 이후 C++라는 형태로 OO가 등장했고, C가 제공하던 완전한 캡슐화가 깨지게 되었다.
		- 언어에 public, private, protected 키워드를 도입함으로써 불완전한 캡슐화를 사실상 어느 정도 보완하기는 했으나, 임시방편일 뿐이다.
	- OO가 강력한 캡슐화에 의존한다는 정의는 받아들이기 힘들다. 실제로 많은 OO언어가 캡슐화를 거의 강제하지 않는다.
	- OO 프로그래밍은 프로그래머가 충분히 올바르게 행동함으로써 캡슐화된 데이터를 우회해서 사용하지 않을 거라는 믿음을 기반으로 한다. 하지만 OO언어들이 실제로는 C언어에서 누렸던 완벽한 캡슐화를 약화시켜 온 것은 틀림없다.
- 상속?
	- OO언어가 더 나은 캡슐화를 제공하진 못했지만 상속만큼은 확실히 제공했다.
	- OO언어 이전에도 C에서 상속과 비슷한 기법이 사용 되었다. (상속만큼 편리한 방식은 아니지만) 이 기법으로 다중 상속을 수현하기는 훨씬 더 어려웠다.
- 다형성?
	- OO언어 이전에도 다형성 표현이 가능했다.
	- C 언어에서 FILE 데이터 구조는 open, close, read, write, seek 함수를 가리키는 포인터를 포함한다.
	- getchar()는 STDIN으로 참조되는 FILE 데이터 구조의 read 포인터가 가리키는 함수를 단순히 호출하고, 이처럼 단순한 기법이 모든 OO가 지닌 다형성의 근간이 된다.
	- 함수를 가리키는 포인터를 응용한 것이 다형성이다. 따라서 OO가 새롭게 만든 것은 없다.
	- 하지만 함수 포인터는 직접 사용하면 위험하다. OO 언어는 함수 포인터를 사용하면서 실수할 위험을 없애준다.
- 다형성이 가진 힘
	- 예시: 새로운 입출력 장치가 생겨도 프로그램에는 영향이 없음
	- 플러그인 아키텍처는 입출력 장치 독립성을 지원하기 위해 만들어졌고, 등장 이후 거의 모든 운영체제에서 구현되었다.
	- OO의 등장으로 언제 어디서든 플러그인 아키텍처를 적용할 수 있게 되었다.
- 의존성 역전
	- 다형성이 등장하기 전에 의존성의 방향은 고수준 -> 저수준으로 반드시 제어흐름을 따르게 되었다.
	- 하지만 다형성의 등장으로 의존성을 어디서든 역전시킬 수 있게 되었다.
	- 의존성 역전을 통해, 특정 컴포넌트의 소스 코드가 변경되면 해당 코드가 포함된 컴포넌트가 다시 배포하면 되는 배포 독립성을 가질 수 있게 되었다.
- 결론
	- OO란 다형성을 이용하여 전체 시스템의 모든 소스 코드 의존성에 대한 절대적인 제어 권한을 획득할 수 있는 능력이다.
	- OO를 사용하면 아키텍트는 플러그인 아키텍처를 구성할 수 있고, 이를 통해 고수준의 정책을 포함하는 모듈은 저수준의 세부사항을 포함하는 모듈에 대해 독립성을 보장할 수 있다.
	- 저수준의 세부사항은 중요도가 낮은 플러그인 모듈로 만들 수 있고, 고수준의 정책을 포함하는 모듈과는 독립적으로 개발하고 배포할 수 있다.

### 6장 함수형 프로그래밍
- 함수형 프로그래밍이라는 패러다임에서 핵심이 되는 기반은 람다 계산법으로, 1930년대에 발명되었다.
- 함수형 프로그래밍 예시
	- java
		```java
		public class Squint {
			public static void main(String args[]){
				for (int i = 0; i < 25; i++)
					System.out.println(i*i);
			}
		}
		```
	- 클로저 (함수형 언어)
		```
		(println (take 25 (map (fn [x] (* x x)) (range))))


		// (println ;___ 출력한다.
		//  (take 25 ;___ 처음부터 25까지
		//   (map (fn [x] (* x x)) ;___ 제곱을
		//    (range)))) ;___ 정수의
		```
		- 함수형 언어에서는 변수는 변경되지 않는다. (x와 같은 변수가 한번 초기화 되면 절대 변하지 않음)

- 불변성과 아키텍처
	- race 조건, 데드락 조건, 동시 업데이트 문제는 모두 가변 변수로 인해 발생한다.
	- 불변성은 실현 가능하겠지만 일종의 타협을 해야한다. 어떤 타협이 필요한지 알아보자
- 가변성의 분리
	- 불변성과 관련해 가장 주요한 타협 중 하나는 애플리케이션, 또는 애플리케이션 내부의 서비스를 가변 컴포넌트와 불변 컴포넌트로 분리하는 일이다.
	- 불변 컴포넌트에서는 순수하게 함수형 방식으로만 작업이 처리되며, 어떤 가변 변수도 사용되지 않는다.
	- 현명한 아키텍트라면 가능한 한 많은 처리를 불변 컴포넌트로 옮겨야 하고, 가변 컴포넌트에서는 가능한 한 많은 코드를 빼내야 한다.
- 이벤트 소싱
	- 이벤트 소싱은 상태가 아닌 트랜잭션을 저장하자는 전략이다. 상태가 필요해졌을 때 상태의 시작점부터 모든 트랜잭션을 처리한다.
	- 매우 많은 저장 공간과 처리 능력이 필요하다.
	- 데이터 저장소에서 삭제되거나 변경되는 것이 하나도 없다. CRUD가 아니라 CR만 수행함
	- 데이터 저장소에서 변경과 삭제가 전혀 발생하지 않으니 동시 업데이트 문제가 일어나지 않는다.
	- 저장 공간과 처리 능력이 충반하다면 애플리케이션이 완전한 불변성, 완전한 함수형으로 만들 수 있다.
	- 소스 코드 버전 관리 시스템이 정확히 이 방식으로 동작한다.
- 결론
	- 요약
		- 구조적 프로그래밍은 제어흐름의 직접적인 전환에 부과되는 규율이다.
		- 객체 지향 프로그래밍은 제어흐름의 간접적인 전환에 부과되는 규율이다.
		- 함수형 프로그래밍은 변수 할당에 부과되는 규율이다.
	- 소프트웨어의 핵심은 항상 그대로다.
		- 순차, 분기, 반복, 참조

## 3부 설계 원칙
- SOLID 원칙의 목적은 중간 수준의 소프트웨어 구조가 아래와 같도록 만드는 데 있다.
	- 변경에 유연하다.
	- 이해하기 쉽다.
	- 많은 소프트웨어 시스템에 사용될 수 있는 컴포넌트의 기반이 된다.
- '중간수준'이라 함은 프로그래머가 이들 원칙을 모듈 수준에서 작업할 때 적용할 수 있다는 뜻이다. 즉, 코드 수준보다는 조금 상위에서 적용되며 모듈과 컴포넌트 내부에서 사용되는 소프트웨어 구조를 정의하는데 도움을 준다.
- SOLID 원칙의 대략적인 설명
	- SRP: 단일 책임 원칙
		- 각 소프트웨어 모듈은 변경의 이유가 하나, 단 하나여야만 한다.
	- OCP: 개방-폐쇄 원칙
		- 기존 코드를 수정하기보다는 반드시 새로운 코드를 추가하는 방식으로 시스템의 행위를 변경할 수 있도록 설계해야만 소프트웨어 시스템을 쉽게 변경할 수 있다는 것이 요지이다.
	- LSP: 리스코프 치환 원칙
		- 상호 대체 가능한 구성요소를 이용해 소프트웨어 시스템을 만들 수 있으려면, 이들 구성요소는 반드시 서로 치환 가능해야 한다는 계약을 반드시 지켜야 한다.
	- ISP: 인터페이스 분리 원칙
		- 이 원칙에 따르면 소프트웨어 설계자는 사용하지 않은 것에 의존하지 않아야 한다.
	- DIP: 의존성 역전 원칙
		- 고수준 정책을 구현하는 코드는 저수준 세부사항을 구현하는 코드에 절대로 의존해서는 안된다. 대신 세부사항이 정책에 의존해야 한다.

### 7장 SRP: 단일 책임 원칙
- 모든 모듈이 단 하나의 일만 해야한다는 의미로 오해하지 말자. 이 원칙은 함수에 적용되는 원칙이다.
- SRP의 최종 버전은 다음과 같다.
	- 하나의 모듈은 하나의, 오직 하나의 액터에 대해서만 책임져야 한다.
- 모듈이란? 가장 단순한 정의는 바로 소스 파일이다. (또는 함수와 데이터 구조로 구성된 응집된 집합)
- SRP를 위반하는 징후들
	- 징후 1: 우발적 중복
		- Employee 클래스 안에 calculatePay(), reportHours(), save() 메서드가 있다.
		- 이 클래스는 회계팀->calculatePay(), 인사팀->reportHours(), DB관리자->save() 메서드를 사용한다.
		- 예를들어 편의를 위해 초과 근무를 제외한 업무 시간을 계산하는 regularHours()라는 메서드를 회계팀->calculatePay(), 인사팀->reportHours()메서드가 함께 공유한다고 하자.
		- 이경우 회계팀에서 요구사항이 들어와 regularHours()를 수정했을 때, 잘못된 데이터로 인해 수백만 달러의 예산을 지출한 인사팀의 격노를 경험할 수 있다.
		- SRP는 서로 다른 액터가 의존하는 코드를 서로 분리하라고 말한다.
	- 징후 2: 병합
		- DB관리자, 인사팀의 요구사항으로 인해 두 명의 서로 다른 개발자가, 다른 Employee 클래스를 수정한다고 했을 때 변경사항은 서로 충돌한다. 결과적으로 병합이 발생하여 위험이 따른다.
		- 이 문제를 벗어나는 방법은 서로 다른 액터를 뒷받침하는 코드를 서로 분리하는 것이다.
		- 해결책은 다양한데, 그 모두가 메서드를 각기 다른 클래스로 이동시키는 방식이다.
			- 아마도 가장 확실한 해결책은 데이터와 메서드를 분리하는 방식이다.
				- 즉 아무런 메서드가 없는 간단한 데이터 구조 EmployeeData 클래스를 만들고, 세 클래스가 공유하도록 한다. 세 클래스는 서로의 존재를 모르고, '우연한 중복'을 피할 수 있다.
			- 반면 위 해결책은 개발자가 세 가지 클래스를 인스턴스화하고 추적해야 한다는 게 단점이다. 이러한 난관에서 빠져나올 때 흔히 쓰는 기법으로 파서드(Facade) 패턴이 있다.
				- EmployeeFacade에 코드는 거의 없고, 이 클래스는 세 클래스의 객체를 생성하고, 요청된 메서드를 가지는 객체로 위임하는 일을 책임진다.
	- 결론
		- 단일 책임 원칙은 메서드와 클래스 수준의 원칙이다. 하지만 이보다 상위의 두 수준에서도 다른 형태로 다시 등장한다. 컴포넌트 수준에서는 공통 폐쇄 원칙이 된다. 아키텍처 수준에서는 아키텍처 경계의 생성을 책임지는 변경의 축이 된다.

### 8장 OCP: 개방-폐쇄 원칙
- 소프트웨어 개체는 확장에는 열려 있어야 하고, 변경에는 닫혀 있어야 한다.
- 다시 말해 소프트웨어 개체의 행위는 확장할 수 있어야 하지만, 이때 개체를 변경해서는 안 된다.
- 결론
	- OCP는 시스템의 아키텍처를 떠받치는 원동력 중 하나다. OCP의 목표는 시스템을 확장하기 쉬운 동시에 변경으로 인해 시스템이 너무 많은 영향을 받지 않도록 하는 데 있다.
	- 이러한 목표를 달성하려면 시스템을 컴포넌트 단위로 분리하고, 저수준 컴포넌트에서 발생한 변경으로부터 고수준 컴포넌트를 보호할 수 있는 형태의 의존성 계층구조가 만들어지도록 해야 한다.

### 9장 LSP: 리스코프 치환 원칙
- S 타입의 객체 o1 각각에 대응하는 T 타입 객체 o2가 있고, T 타입을 이용해서 정의한 모든 프로그램 P에서 o2의 자리에 o1을 치환하더라도 P의 행위가 변하지 않는다면, S는 T의 하위 타입이다.
- 결론
	- LSP는 아키텍처 수준까지 확장할 수 있고, 반드시 확장해야만 한다. 치환 가능성을 조금이라도 위배하면 시스템 아키텍처가 오염되어 상당량의 별도 메커니즘을 추가해야 할 수 있기 때문이다.

### 10장 ISP: 인터페이스 분리 원칙
- 의존성으로 인해 관련이 없는 코드의 변경이 있더라도 재컴파일, 재배포가 일어날 수 있다.
- 오퍼레이션을 인터페이스 단위로 분리하여 해결이 가능하다.
- 결론
	- 불필요한 짐을 실은 무언가에 의존하면 예상치도 못한 문제에 빠진다.

### 11장 DIP: 의존성 역전 원칙
- 의존성 역전 원칙에서 말하는 '유연성이 극대화된 시스템'이란 소스 코드 의존성이 추상에 의존하며 구체에는 의존하지 않는 시스템이다.
- 안정된 추상화
	- 변동성이 큰 구체 클래스를 참조하지 말라
		- 대신 추상 인터페이스를 참조하라
		- 이 규칙은 객체 생성 방식을 강하게 제약하며, 일반적으로 추상 팩토리를 사용하도록 강제한다.
	- 변동성이 큰 구체 클래스로부터 파생하지 말라
		- 정적 타입언어에서 상속은 소스 코드에 존재하는 모든 관계 중에서 가장 강력한 동시에 뻣뻣해서 변경하기 어렵다.
		- 따라서 상속은 아주 신중하게 사용해야 한다.
	- 구체 함수를 오버라이드 하지 말라
		- 대체로 구체 함수는 소스 코드 의존성을 필요로 하기 때문에, 구체 함수를 오버라이드 하면 이러한 의존성을 제거할 수 없게 되며, 실제로는 그 의존성을 상속하게 된다.
		- 이러한 의존성을 제거하려면, 차라리 추상 함수로 선언하고 구현체들에서 각자의 용도에 맞게 구현해야 한다.
	- 구체적이며 변동성이 크다면 절대로 그 이름을 언급하지 말라.
		- 이 실천법은 DIP 원칙을 다른 방식으로 풀어쓴 것이다.
- 팩토리
	- 이 규칙들을 준수하려면 변동성이 큰 구체적인 객체는 특별히 주의해서 생성해야 한다.
	- 대다수의 객체 지향 언어에서 바람직하지 못한 의존성을 처리할 때 추상 팩토리를 사용하곤 한다.
- 결론
	- DIP는 아키텍처 다이어그램에서 가장 눈에 드러나는 원칙이 될 것이다.

## 4부 컴포넌트 원칙
- SOILD 원칙이 벽과 방에 벽돌을 배치하는 방법을 알려준다면, 컴포넌트 원칙은 빌딩에 방을 배치하는 방법을 설명해준다.
- 4부에서는 소프트웨어 컴포넌트가 무엇인지, 컴포넌트를 구성하는 요소는 무엇인지 알아보고, 컴포넌트를 결합하여 시스템을 구성하는 방법에 대해 논의한다.

### 12장 컴포넌트
- 컴포넌트는 배포 단위다. 컴포넌트는 시스템의 구성 요소로 배포할 수 있는 가장 작은 단위다.
- 자바의 경우 jar 파일이 컴포넌트, 닷넷에서는 DLL이다. 컴파일형 언어에서 컴포넌트는 바이너리 파일의 결합체다.
- 여러 컴포넌트를 서로 링크하여 실행 가능한 단일 파일로 생성할 수 있다. 또는 컴포넌트 각각을 .jar나 .dll같이 동적으로 로드할 수 있는 플러그인이나 .exe 파이롤 만들어서 독립적으로 배포할 수 있다.
- 컴포넌트가 마지막에 어떤 형태로 배포되든, 잘 설계된 컴포넌트라면 반드시 독립적으로 배포 가능한, 따라서 독립적으로 개발 가능한 능력을 갖춰야 한다.
- 결론
	- 런타임에 플러그인 형태로 결합할 수 있는 동적 링크 파일이 이 책에서 말하는 소프트웨어 컴포넌트에 해당한다. 과거에는 초인적인 능력을 들여야하만 플러그인 아키텍처를 적용할 수 있었지만, 이제는 기본으로 쉽게 사용할 수 있는 지점까지 다다랐다.

### 13장 컴포넌트 응집도
- 컴포넌트 응집도와 관련된 세 가지 원칙이 있다.
	- REP(Reuse/Release Equivalence Principle): 재사용/릴리스 등가 원칙
		- 재사용 단위는 릴리스 단위와 같다.
		- 하나의 컴포넌트로 묶인 클래스와 모듈은 반드시 함께 릴리스할 수 있어야 한다.
	- CCP(Common Closure Principle): 공통 폐쇄 원칙
		- 동일한 이유로 동일한 시점에 변경되는 클래스를 같은 컴포넌트로 묶어라. 서로 다른 시점에 다른 이유로 변경되는 클래스는 다른 컴포넌트로 분리하라.
		- 이 원칙은 단일 책임 원칙(SRP)을 컴포넌트 관점에서 다시 쓴 것이다.
		- CCP는 변경될 가능성이 있는 클래스는 모두 한곳으로 묶을 것을 권한다. 이를 통해 릴리스, 재검증, 배포하는 일과 관련된 작업량을 최소화할 수 있다.
	- CRP(Common Reuse Principle): 공통 재사용 원칙
		- 컴포넌트 사용자들을 필요하지 않는 것에 의존하게 강요하지 말라.
		- CRP는 인터페이스 분리 원칙(ISP)의 포괄적인 버전이다. CRP는 사용하지 않는 클래스를 가진 컴포넌트에 의존하지 말라고 조언한다. 이 두 원칙은 한 문장으로 요약할 수 있다.
		- 필요하지 않은 것에 의존하지 말라
- 컴포넌트 응집도에 대한 균형 다이어그램
	- 프로젝트 초기에는 유지보수성에 중점을 두고 재사용성은 중요도를 낮추자
	- 프로젝트가 진행 될 수록 점차 유지보수성보다 재사용성에 중점을 둔다.

### 14장 컴포넌트 결합
- 지금부터 다룰 세 가지 원칙은 컴포넌트 사이의 관계를 설명한다.
- ADP: 의존성 비순환 원칙
	- 컴포넌트 의존성 그래프에 순환(cycle)이 있어서는 안 된다.
	- 하루 종일 일해서 무언가를 만들고 퇴근했는데, 이튿날 출근해 보면 전혀 돌아가지 않는 경험을 해본 적이 있는가? 왜냐하면 누군가가 더 늦게까지 일하면서 당신이 의존하고 있던 무언가를 수정했기 때문이다. (숙취 증후군)
	- 이 문제의 해결책은 두가지이다.
		- 주 단위 빌드(Weekly Build)
			- 중간 규모의 프로젝트에서는 흔하게 사용 된다.
			- 먼저 모든 개발자는 일주일의 첫 4일 동안은 서로를 신경 쓰지 않고, 어떻게 통합할지 걱정하지 않는다. 그런 후 금요일이 되면 변경된 코드를 모두 통합하여 시스템을 빌드한다.
			- 안타깝게도 프로젝트가 커지면 프로젝트 통합은 금요일 하루만에 끝마치는게 불가능해진다. 개발보다 통합에 드는 시간이 늘어나면서 팀의 효율성도 서서히 나빠진다.
		- 순환 의존성 제거하기
			- 이 문제의 해결책은 개발 환경을 릴리스 가능한 컴포넌트 단위로 분리하는 것이다.
			- 이를 통해 컴포넌트는 개별 개발자 또는 단일 개발팀이 책임질 수 있는 작업 단위가 된다.
			- 이 절차가 성공적으로 동작하려면 컴포넌트 사이의 의존성 구조를 반드시 관리해야 한다. 의존성 구조에 순환이 있어서는 안 된다. 순환이 생기면 '숙취 증후군'을 피해 갈 수 없다.
			- 컴포넌트 다이어그램에서 어느 컴포넌트에서 시작하더라도, 의존성 관계를 따라가면서 최초의 컴포넌트로 되돌아갈 수 없어야 한다.
		- 순환이 컴포넌트 의존성 그래프에 미치는 영향
			- 순환이 이루어지면 순환하는 여러개의 컴포넌트가 사실상 하나의 거대한 컴포넌트가 되어 버린다.
			- 이 컴포넌트 중 어느 것을 개발하더라도 '숙취 증후군'에 떠는 경험을 하게 될 것이다.
		- 순환 끊기
			- 의존성 역전 원칙 적용
			- 두 컴포넌트가 의존하는 새로운 컴포넌트를 만든다. 의존하는 클래스들을 새로운 컴포넌트로 이동시킨다.
		- 흐트러짐
			- 두 번째 해결책에서 시사하는 바는 요구사항이 변경되면 컴포넌트 구조도 변경될 수 있다는 사실이다.
			- 실제로 애플리케이션이 성장함에 따라 컴포넌트 의존성 구조는 서서히 흐트러지며 또 성장한다. 따라서 의존성 구조에 순환이 발생하는지를 항상 관찰해야 한다.
			- 순환이 발생하면 어떤 식으로든 끊어야 한다. 이 말은 때론 새로운 컴포넌트를 생성하거나 의존성 구조가 더 커질 수도 있음을 의미한다.
- 하향식(top-down) 설계
	- 지금까지 논의로 우리는 피할 수 없는 결론에 다다르게 된다. 즉, 컴포넌트 구조는 하향식으로 설계될 수 없다. 컴포넌트는 시스템에서 가장 먼저 설계할 수 있는 대상이 아니다.
	- 컴포넌트 의존성 다이어그램은 애플리케이션의 기능을 기술하는 일과는 거의 관련이 없다. 오히려 컴포넌트 의존성 다이어그램은 애플리케이션의 빌드 가능성과 유지보수성을 보여주는 지도와 같다.
	- 아직 아무런 클래스도 설계하지 않은 상태에서 컴포넌트 의존성 구조를 설계하려고 시도한다면 상당히 큰 실패를 맛볼 수 있다. 컴포넌트 의존성 구조는 시스템의 논리적 설계에 발맞춰 성장하며 또 진화해야 한다.
- SDP: 안정된 의존성 원칙
	- 안정성의 방향으로(더 안정된 쪽에) 의존하라.
	- 설계는 결코 정적일 수 없다. 설계를 유지하다 보면 변경은 불가피하다.
	- 변경이 쉽지 않은 컴포넌트가 변동이 예상되는 컴포넌트에 의존하게 만들어서는 절대로 안 된다.
	- 즉, 당신이 모듈을 만들 때는 변경하기 쉽도록 설계했지만, 이 모듈에 누군가가 의존성을 매달아 버리면 당신의 모듈도 변경하기 어려워진다.
	- 안정된 의존성 원칙(Stable Dependencies Principle, SDP)을 준수하면 변경하기 어려운 모듈이 변경하기 쉽게 만들어진 모듈에 의존하지 않도록 만들 수 있다.
	- 안정성
		- 컴포넌트 안으로 들어오는 의존석이 많아지면 상당히 안정적이라고 볼 수 있다. 사소한 변경이라도 의존하는 모든 컴포넌트를 만족시키면서 변경하려면 상당한 노력이 들기 때문이다.
		- 다수의 컴포넌트가 X 컴포넌트에 의존하고 있고, 그 X 컴포넌트는 다른 컴포넌트를 의존하지 않으면 그 X 컴포넌트는 안정적이다. 이 경우 X는 독립적이다라고 말한다.
		- 반대로 어떤 컴포넌트도 Y 컴포넌트에 의존하지 않아 책임성이 없고, Y가 다수의 컴포넌트에 의존하는 경우 변경이 발생할 수 있는 요인이 많아진다. 이 경우 Y는 의존적이라고 말한다.
	- 안정성 지표
		- 컴포넌트로 들어오고 나가는 의존성의 개수를 세어 보고, 이 숫자를 통해 컴포넌트가 위치상 어느 정도의 안정성을 가지는지 계산할 수 있다.
		- Fan-in: 안으로 들어오는 의존성
		- Fan-out: 바깥으로 나가는 의존성
		- I(불안정성): I = Fan-out / (Fan-in + Fan-out). <br>
			이 지표는 [0,1] 범위의 값을 갖는다. I = 0 이면 최고로 안정된 컴포넌트라는 뜻이다.
	- 모든 컴포넌트가 안정적이어야 하는 것은 아니다.
		- 모든 컴포넌트가 최고로 안정적인 시스템이라면 변경이 불가능하다. 우리가 기대하는 것은 불안정한 컴포넌트도 있고 안정된 컴포넌트도 존재하는 상황이다.
		- 안정된 컴포넌트가 불안정한 컴포넌트에 의존성을 가지게 될경우, DIP(의존성 역전 원칙)을 도입하여 이 문제를 해결할 수 있다. 불안정한 컴포넌트의 인터페이스를 생성하여 이를 참조하도록 하게 한다.
- SAP: 안정된 추상화 원칙
	- 컴포넌트는 안정된 정도만큼만 추상화되어야 한다.
	- 고수준 정책을 어디에 위치시켜야 하는가?
		- 시스템에는 자주변경해서는 절대로 안되는 소프트웨어도 있다.
		- 고수준 아키텍처나 정책 결정과 관련된 소포트웨어가 그 예다.
		- 고수준 정책을 안정된 컴포넌트에 위치시키면, 그 정책을 포함하는 소스 코드는 수정하기가 어려워진다. 컴포넌트가 최고로 안정된 상태이면서도 동시에 변경에 충분히 대응할 수 있을 정도로 유연하게 만들 수 있을까?
		- 해답은 개방 폐쇄 원칙(OCP)에서 찾을 수 있다.
	- 안정된 추상화 원칙
		- 이 원칙은 안정된 컴포넌트는 추상 컴포넌트여야하고, 불안정안 컴포넌트는 반드시 구체 컴포넌트여야 한다고 말한다.
	- 추상화 정도 측정하기
		- Nc: 컴포넌트의 클래스 개수
		- Na: 컴포넌트의 추상 클래스와 인터페이스의 개수
		- A: 추상화 정도. A = Na / Nc
		- A 지표는 0과 1 사이의 값을 갖는다. 0이면 추상클래스가 하나도 없다는 뜻이고, 1이면 오로지 추상클래스만 있다는 뜻이다.
- 결론
	- 의존성 관리 지표를 통해 의존성과 추상화 정도가 '훌륭한'패턴이라고 생각하는 수준에 얼마나 잘 부합하는지를 측정할 수 있다.

## 5부 아키텍처
### 15장 아키텍처란?
- 선택사항 열어 두기
	- 중요치 않은 세부사항을 결정하는 일은 미루거나 연기할 수 있다.
	- 개발 초기에는 DB, 웹 서버를 선택할 필요가 없다.
	- 개발 초기에는 REST, 의존성 주입 프레임워크를 적용할 필요가 없다.
	- 좋은 아키텍트는 결정되지 않은 사항의 수를 최대화한다.

### 16장 독립성
- 좋은 아키텍처는 다음을 지원해야 한다.
	- 시스템의 유스케이스
	- 시스템의 운영
	- 시스템의 개발
	- 시스템의 배포

### 17장 경계: 선 긋기
- 예를 들어 DB 가 정해지지 않았을 때 DB에 접근하는 인터페이스만 만들어놓고 DB와 업무 규칙 사이에 경계선을 그어 DB에 대한 어떤 것도 모르게 한다.
- 소프트웨어 아키텍처에서 경계선을 그리려면 먼저 시스템을 컴포넌트 단위로 분할해야 한다.
	- 일부 컴포넌트는 핵심 업무 규칙에 해당한다.
	- 나머지 컴포넌트는 플러그인으로, 핵심 업무와는 직접적인 관련이 없지만 필수 기능을 포함한다.

### 18장 경계 해부학
- 경계 횡단하기
	- '런타임에 경계를 횡단한다'함은 그저 경계 한쪽에 있는 기능에서 반대편 기능을 호출하여 데이터를 전달하는 일에 불과하다. 적절한 위치에서 경계를 횡단하게 하는 비결은 소스 코드 의존성 관리에 있다.
	- 소스 코드 모듈 하나가 변경되면, 이에 의존하는 다른 소스 코드 모듈도 변경하거나, 다시 컴파일해서 새로 배포해야 할 지도 모르기 때문이다.
	- 경계는 이러한 변경이 전파되는 것을 막는 방화벽을 구축하고 관리하는 수단으로써 존재한다.

### 19장 정책과 수준
- 수준을 엄밀하게 정의하자면 '입력과 출력까지의 거리'다. 입력과 출력 모두로부터 멀리 위치할수록 정책의 수준은 높아진다.
- 고수준 컴포넌트가 저수준 함수에 의존하지 않도록하자.
- 예를들어 암호화 컴포넌트가 IO Device 컴포넌트에 의존하지 않도록, IO Device가 암호화 컴포넌트에 의존하도록 해야한다.

### 20장 업무 규칙
- 업무 규칙은 사용자 인터페이스나 데이터베이스와 같은 저수준의 관심사로 인해 오염되어서는 안 된다.
- 업무 규칙은 시스템에서 가장 독립적이며 가장 많이 재사용할 수 있는 코드여야 한다.

### 21장 소리치는 아키텍처
- 아키텍처는 시스템을 이야기해야 하며, 시스템에 적용한 프레임워크에 대해 이야기해서는 안 된다.

### 22장 클린 아키텍처
- 소스 코드 의존성은 반드시 안쪽으로, 고수준(입력과 출력으로부터 거리가 먼)의 정책을 향해야 한다.
- 내부의 원에 속한 요소는 외부의 원에 속한 어떤 것도 알지 못한다.
- 소프트웨어를 계층으로 분리하고 의존성 규칙을 준수한다면 본질적으로 테스트하기 쉬운 시스템을 만들게 될 것이며, 그에 따른 이점을 누릴 수 있다.
	- 데이터베이스나 웹 프레임워크와 같은 시스템의 외부 요소가 구식이 되더라도, 이들 요소를 야단스럽지 않게 교체할 수 있다.

### 23장 프레젠터와 험블 객체
- 험블 객체 패턴은 디자인 패턴으로, 테스트하기 어려운 행위와 테스트하기 쉬운 행위를 단위 테스트 작성자가 분리하기 쉽게 하는 방법으로 고안되었다.
- 행위들을 두 개의 모듈 또는 클래스로 나눠 가장 기본적은 본질은 남기고, 테스트 하기 어려운 행위를 험블 객체로 옮긴다.
- 프레젠터와 뷰
	- 뷰는 험블 객체이고 테스트하기 어렵다. 뷰는 GUI로 데이터를 이동시켜 보여주는 객체이다.
	- 프레젠터는 테스트하기 쉽다.

### 24장 부분적 경계
- 아키텍처 경계를 완벽하게 만드는 데는 비용이 많이 든다. YAGNI(필요한 작업만 해라)원칙을 위배할 수 있다. 그렇다면 부분적 경계를 구현해 볼 수 있다.
	- 마지막 단계를 건너뛰기
		- 독립적으로 컴파일하고 배포할 수 있는 컴포넌트를 만들기 위한 작업은 모두 수행한 후, 단일 컴포넌트에 그대로 모아만 두는 것이다.
		- 다수의 컴포넌트를 관리하는 작업은 하지 않아도 되고, 추적을 위한 버전 번호도 없으며 배포 관리 부담도 없다.
	- 일차원 경계
		- 양방향으로 격리된 상태를 유지하려면 초기 설정할 때나 지속적으로 유지할 때도 비용이 많이 든다.
		- 추후 완병한 형태의 경계로 확장할 수 있는 공간을 확보하고자 할 때 활용할 수 있는 간단한 구조는 Service 인터페이스와 ServiceImple 클래스 구현 방법이 전형적인 사례다.
	- 퍼사드 패턴
		- 더 단순한 경계는 퍼사드 패턴으로, 이 경우에는 심지어 의존성 역전까지도 희생한다.
		- Facade 클래스에는 모든 서비스 클래스를 메서드 형태로 정의하고, 서비스 호출이 발생하면 해당 서비스 클래스로 호출을 전달한다. 클라이언트는 서비스 클래스에 직접 접근할 수 없다. Facade를 통해서만 접근 가능.

### 25장 계층과 경계
- 아키텍처 경계는 아무리 간단한 프로그램이어도 존재한다.
- 이러한 아키텍처 경계를 제대로 구현하려면 비용이 많이 든다. 동시에 이러한 경계가 무시되었다면 나중에 다시 추가하는 비용이 크다.
- 하지만 추상화가 필요하리라고 미리 예측해서는 안된다. 오버 엔지니어링이 언더 엔지니어링보다 나쁠 때가 훨씬 많기 때문이다.
- 프로젝트 초반에는 구현할 경계가 무엇인지와 무시할 경계가 무엇인지를 쉽게 결정할 수 없다.
- 우리의 목표는 경계의 구현 비용이 그걸 무시해서 생기는 비용보다 적어지는 바로 그 변곡점에서 경계를 구현하는 것이다. 목표를 달성하려면 빈틈없이 지켜봐야 한다.

### 26장 메인 컴포넌트
- 메인 컴포넌트는 초기 조건과 설정을 구성하고, 외부 자원을 모두 수집한 후, 제어권을 애플리케이션의 고수준 정책으로 넘기는 플러그인이다.
- 메인을 플러그인 컴포넌트로 여기고, 그래서 아키텍처 경계 바깥에 위치한다고 보면 설정 관련 문제를 훨씬 쉽게 해결할 수 있다.

### 27장 '크고 작은 모든' 서비스들
- 서비스의 이점?
	- 결합 분리의 오류
		- 항상 서비스 사이의 결합이 확실히 분리 되는 것은 아니다.
		- 서로 공유하는 데이터가 있다면 이 데이터에 새로운 필드가 추가 되었을 때 모든 서비스가 변경되어야 한다.
	- 개발 및 배포 독립성의 오류
		- 대규모 엔터프라이즈 시스템은 서비스 기반이 아닌 모노리틱 시스템, 컴포넌트 기반 시스템으로도 구축할 수 있다. 서비스는 유일한 선택지가 아니다.
		- '결합 분리의 오류'에 따르면 서비스라고 해서 항상 독립적으로 개발하고, 배포하며, 운영할 수 있는 것은 아니다.
- 결론
	- 서비스는 시스템의 확장성과 개발 가능성 측면에서 유용하지만, 그 자체로는 아키텍처적으로 그리 중요한 요소는 아니다.

### 28장 테스트 경계
- 테스트는 시스템 외부에 있지 않다. 오히려 시스템의 일부다. 따라서 테스트에서 기대하는 안정성과 회귀의 이점을 얻을 수 있으려면 테스트는 잘 설계돼야만 한다.
- 테스트를 시스템의 일부로 설계하지 않으면 테스트는 깨지기 쉽고 유지보수하기 어려워지는 경향이 있다. 이러한 테스트는 유지보수하기가 너무 힘들기 때문에 결국 방바닥의 휴지처럼 버려지는 최후를 맞는다.

### 29장 클린 임베디드 아키텍처

### 30장 데이터베이스는 세부사항이다
- 체계화 된 데이터 구조와 데이터 모델은 아키텍처적으로 중요하다. 반면, 그저 데이터를 회전식 자기 디스크 표면에서 이리저리 옮길 뿐인 기술과 시스템은 아키텍처적으로 중요하지 않다.
- 데이터는 중요하다. 데이터베이스는 세부사항이다.

### 31장 웹은 세부사항이다
- GUI는 세부사항이다. 웹은 GUI다. 따라서 웹은 세부사항이다. 아키텍트라면 이러한 세부사항을 핵심 업무 로직에서 분리된 경계 바깥에 두어야 한다.

### 32장 프레임워크는 세부사항이다
- 프레임워크를 사용할 수는 있지만, 프레임워크와 결합하지는 마라. 적당히 거리를 두고 프레임워크가 아키텍처의 안쪽 원으로 들어오지 못하게 해라.

### 33장 사례 연구: 비디오 판매
- 두가지 차원의 분리 개념(단일 책임 원칙에 기반한 액터의 분리, 의존성 규칙)으로 컴포넌트를 분리하여 구조화하고 나면 시스템을 실제로 배포하는 방식을 다양하게 선택할 수 있게 된다.

### 34장 빠져 있는 장
- 최적의 설계를 꾀했더라도, 구현 전략에 얽힌 복잡함을 고려하지 않으면 설계가 순식간에 망가질 수도 있다.
- 설계를 어떻게 해야만 원하는 코드 구조로 매핑할 수 있을지, 그 코드를 어떻게 조직화할지, 런타임과 컴파일타임에 어떤 결합 분리 모드를 적용할지 고민해라.
- 가능하다면 선택사항을 열어두되, 실용주의적으로 행하고 팀의 규모, 기술 수준, 해결책의 복잡성을 일정과 예산이라는 제약과 동시에 고려해라.
- 선택된 아키텍처 스타일을 강제하는 데 컴파일러의 도움을 받을 수 있을지를 고민하고 데이터 모델과 같은 다른 영역에 결합되지 않도록 주의하라.

### 35장 부록: 아키텍처 고고학