# Clean Architecture
## 1부 소개
### 1장 설계와 아키텍처란?
- 설계(design)와 아키텍처(architecture)가 무엇인가?
	- 아키텍처는 저수준의 세부사항과는 분리된 고수준의 무언가를 가리킬 때 흔히 사용
	- 설계는 저수준의 구조 또는 결정사항 등을 의미할 때가 많다.
	- 하지만 아키텍트가 실제로 하는 일을 살펴보면 이러한 구분은 무의미
- 이러한 의사결정의 목표는?
	- 소프트웨어 아키텍처의 목표는 필요한 시스템을 만들고 유지보수하는 데 투입되는 인력을 최소화하는 데 있다.
- 결론
	- 개발 조직이 할 수 있는 최고의 선택지는 조직에 스며든 과신을 인지하여 방지하고, 소프트웨어 아키텍처의 품질을 심각하게 고민하기 시작하는 것이다.

### 2장 두 가지 가치에 대한 이야기
- 모든 소프트웨어 시스템은 이해관계자에게 행위(behavior), 구조(structure) 두 가지 가치를 제공한다. 두 가치를 모두 반드시 높게 유지해야 한다.
- 행위
	- 프로그래머를 고용하는 이유는 이해관계자를 위해 기계가 수익을 창출하거나 비용을 절약하도록 만들기 위해서다.
	- 이를 위해 프로그래머는 이해관계자가 기능 명세서나 요구사항문서를 구체화할 수 있도록 돕는다. 그리고 이해관계자의 기계가 이러한 요구사항을 만족하도록 코드를 작성한다.
	- 기계가 이러한 요구사항을 위반하면, 프로그래머는 디버거를 열고 문제를 고친다.
	- 많은 프로그래머가 이러한 활동이 자신이 해야 할 일의 전부라고 생각한다.
- 아키텍처
	- 소프트웨어는 반드시 부드러워야 한다.(변경사항을 간단하고 쉽게 적용할 수 있어야 한다.)
	- 아키텍처가 특정 형태를 다른 형태보다 선호하면 할수록, 새로운 기능을 이 구조에 맞추는 게 더 힘들어진다.
	- 따라서 아키텍처는 형태에 독립적이어야 하고, 그럴수록 더 실용적이다.
- 아이젠하워 매트릭스
	1. 긴급하고 중요한
	2. 긴급하지는 않지만 중요한
	3. 긴급하지만 중요하지 않은
	4. 긴급하지도 중요하지도 않은
	- 아키텍처, 즉 중요한 일은 이 항목의 가장 높은 두 순위를 차지하지만, 행위는 첫 번째와 세 번째에 위치한다.
	- 업무 관리자와 개발자가 흔하게 저지르는 실수는 세 번째에 위치한 항목을 첫 번째로 격상시켜 버리는 일이다. 이러한 실수로 인해 시스템에서 중요도가 높은 아키텍처를 무시한 채 중요도가 떨어지는 기능을 선택하게 된다.
- 아키텍처를 위해 투쟁하라
	- 개발팀은 회사에서 가장 중요하다고 스스로 믿는 가치를 위해 투쟁해야 한다.
	- 아키텍처가 후순위가 되면 시스템을 개발하는 비용이 더 많이 들고, 일부 또는 전체 시스템에 변경을 가하는 일이 현실적으로 불가능해진다.

## 2부 벽돌부터 시작하기: 프로그래밍 패러다임
### 3장 패러다임 개요
- 이 장에서는 세가지 패러다임인 구조적 프로그래밍, 객체지향 프로그래밍, 함수형 프로그래밍에 대해 설명한다.
- 구조적 프로그래밍
	- 최초로 적용된 패러다임
	- Dijkstra는 무분별한 점프(goto 문장)는 프로그램 구조에 해롭다는 사실을 제시했다.
	- Dijkstra는 이러한 점프들을 if/then/else, do/while/until과 같이 더 익숙한 구조로 대체했다.
	- 요약
		- 구조적 프로그래밍은 제어흐름에 직접적인 전환에 대해 규칙을 부과한다.
- 객체 지향 프로그래밍
	- 두번째로 도입된 패러다임
	- 요한 달과 크리스텐 니가드는 알골(ALGOL) 언어의 함수 호출 스택 프레임을 힙으로 옮기면, 함수 호출이 반환된 이후에도 함수에서 선언된 지역 변수가 오랫동안 유지될 수 있음을 발견했다. 이러한 함수가 클래스의 생성자가 되었고, 지역 변수는 인스턴스 변수, 중첩 함수는 메서드가 되었다.
	- 요약
		- 객체 지향 프로그래밍은 제어흐름의 간접적인 전환에 대해 규칙을 부과한다.
- 함수형 프로그래밍
	- 세 번째 패러다임은 최근에 들어서야 겨우 도입되기 시작했지만, 세 패러다임중 가장 먼저 만들어졌다.
	- 함수형 프로그래밍은 람다 계산법의 연구 결과에 직접적인 영향을 받아 만들어졌다.
	- 람다 계산법의 기초가 되는 개념은 불변성으로, 심볼의 값이 변경되지 않는다는 개념이다.
	- 요약
		- 함수형 프로그래밍은 할당문에 대해 규칙을 부과한다.
- 생각할 거리
	- 각 패러다임은 프로그래머에게서 권한을 박탈한다.
	- 어느 패러다임도 새로운 권한을 부여하지 않는다.
	- 즉 무엇을 해서는 안 되는지를 말해준다.
	- 이 패러다임들은 1958년~1968년에 걸쳐서 만들어졌고, 이후 새롭게 등장한 패러다임은 없다.
- 결론
	- 세 가지 패러다임과 아키텍처의 세 가지 큰 관심사(함수, 컴포넌트 분리, 데이터 관리)가 어떻게 서로 연관되는지에 주목하자.

### 4장 구조적 프로그래밍
- 다익스트라는 프로그램을 순차, 분기, 반복이라는 세가지 구조만으로 표현할 수 있다는 사실을 증명했다.
- 다익스트라가 "goto문의 해로움"이라는 편지를 보냈고, 승리했다.
- 테스트
	- 다익스트라는 "테스트는 버그가 있음을 보여줄뿐, 버그가 없음을 보여줄 수는 없다"라고 말한 적이 있다.
	- 다시 말해 프로그램이 잘못되었음을 테스트를 통해 증명할 수는 있지만, 프로그램이 맞다고 증명할 수는 없다.
	- 이 사실은 소프트웨어 개발이 수학적인 구조를 다루는 듯 보이더라도, 수학적인 시도가 아니라는 사실을 담고 있다.
	- 제약 없는 goto문을 사용하는 등의 이유로 입증이 불가능한 프로그램은 테스트를 아무리 많이 수행하더라도 절대로 올바르다고 볼 수 없다.
- 결론
	- 구조적 프로그래밍이 오늘날까지 가치 있는 이유는 프로그래밍에서 반증 가능한 단위를 만들어 낼 수 있는 바로 이 능력 때문이다. 또한 흔히 현대적 언어가 아무런 제약없는 goto 문장은 지원하지 않는 이유이기도 하다. 뿐만 아니라 아키텍처 관점에서는 기능적 분해를 최고의 실천법 중 하나로 여기는 이유이기도 하다.

### 5장 객체 지향 프로그래밍
- 캡슐화?
	- C언어에서도 완벽한 캡슐화가 가능하다.
	- 이후 C++라는 형태로 OO가 등장했고, C가 제공하던 완전한 캡슐화가 깨지게 되었다.
		- 언어에 public, private, protected 키워드를 도입함으로써 불완전한 캡슐화를 사실상 어느 정도 보완하기는 했으나, 임시방편일 뿐이다.
	- OO가 강력한 캡슐화에 의존한다는 정의는 받아들이기 힘들다. 실제로 많은 OO언어가 캡슐화를 거의 강제하지 않는다.
	- OO 프로그래밍은 프로그래머가 충분히 올바르게 행동함으로써 캡슐화된 데이터를 우회해서 사용하지 않을 거라는 믿음을 기반으로 한다. 하지만 OO언어들이 실제로는 C언어에서 누렸던 완벽한 캡슐화를 약화시켜 온 것은 틀림없다.
- 상속?
	- OO언어가 더 나은 캡슐화를 제공하진 못했지만 상속만큼은 확실히 제공했다.
	- OO언어 이전에도 C에서 상속과 비슷한 기법이 사용 되었다. (상속만큼 편리한 방식은 아니지만) 이 기법으로 다중 상속을 수현하기는 훨씬 더 어려웠다.
- 다형성?
	- OO언어 이전에도 다형성 표현이 가능했다.
	- C 언어에서 FILE 데이터 구조는 open, close, read, write, seek 함수를 가리키는 포인터를 포함한다.
	- getchar()는 STDIN으로 참조되는 FILE 데이터 구조의 read 포인터가 가리키는 함수를 단순히 호출하고, 이처럼 단순한 기법이 모든 OO가 지닌 다형성의 근간이 된다.
	- 함수를 가리키는 포인터를 응용한 것이 다형성이다. 따라서 OO가 새롭게 만든 것은 없다.
	- 하지만 함수 포인터는 직접 사용하면 위험하다. OO 언어는 함수 포인터를 사용하면서 실수할 위험을 없애준다.
- 다형성이 가진 힘
	- 예시: 새로운 입출력 장치가 생겨도 프로그램에는 영향이 없음
	- 플러그인 아키텍처는 입출력 장치 독립성을 지원하기 위해 만들어졌고, 등장 이후 거의 모든 운영체제에서 구현되었다.
	- OO의 등장으로 언제 어디서든 플러그인 아키텍처를 적용할 수 있게 되었다.
- 의존성 역전
	- 다형성이 등장하기 전에 의존성의 방향은 고수준 -> 저수준으로 반드시 제어흐름을 따르게 되었다.
	- 하지만 다형성의 등장으로 의존성을 어디서든 역전시킬 수 있게 되었다.
	- 의존성 역전을 통해, 특정 컴포넌트의 소스 코드가 변경되면 해당 코드가 포함된 컴포넌트가 다시 배포하면 되는 배포 독립성을 가질 수 있게 되었다.
- 결론
	- OO란 다형성을 이용하여 전체 시스템의 모든 소스 코드 의존성에 대한 절대적인 제어 권한을 획득할 수 있는 능력이다.
	- OO를 사용하면 아키텍트는 플러그인 아키텍처를 구성할 수 있고, 이를 통해 고수준의 정책을 포함하는 모듈은 저수준의 세부사항을 포함하는 모듈에 대해 독립성을 보장할 수 있다.
	- 저수준의 세부사항은 중요도가 낮은 플러그인 모듈로 만들 수 있고, 고수준의 정책을 포함하는 모듈과는 독립적으로 개발하고 배포할 수 있다.

### 6장 함수형 프로그래밍
- 함수형 프로그래밍이라는 패러다임에서 핵심이 되는 기반은 람다 계산법으로, 1930년대에 발명되었다.
- 함수형 프로그래밍 예시
	- java
		```java
		public class Squint {
			public static void main(String args[]){
				for (int i = 0; i < 25; i++)
					System.out.println(i*i);
			}
		}
		```
	- 클로저 (함수형 언어)
		```
		(println (take 25 (map (fn [x] (* x x)) (range))))


		// (println ;___ 출력한다.
		//  (take 25 ;___ 처음부터 25까지
		//   (map (fn [x] (* x x)) ;___ 제곱을
		//    (range)))) ;___ 정수의
		```
		- 함수형 언어에서는 변수는 변경되지 않는다. (x와 같은 변수가 한번 초기화 되면 절대 변하지 않음)

- 불변성과 아키텍처
	- race 조건, 데드락 조건, 동시 업데이트 문제는 모두 가변 변수로 인해 발생한다.
	- 불변성은 실현 가능하겠지만 일종의 타협을 해야한다. 어떤 타협이 필요한지 알아보자
- 가변성의 분리
	- 불변성과 관련해 가장 주요한 타협 중 하나는 애플리케이션, 또는 애플리케이션 내부의 서비스를 가변 컴포넌트와 불변 컴포넌트로 분리하는 일이다.
	- 불변 컴포넌트에서는 순수하게 함수형 방식으로만 작업이 처리되며, 어떤 가변 변수도 사용되지 않는다.
	- 현명한 아키텍트라면 가능한 한 많은 처리를 불변 컴포넌트로 옮겨야 하고, 가변 컴포넌트에서는 가능한 한 많은 코드를 빼내야 한다.
- 이벤트 소싱
	- 이벤트 소싱은 상태가 아닌 트랜잭션을 저장하자는 전략이다. 상태가 필요해졌을 때 상태의 시작점부터 모든 트랜잭션을 처리한다.
	- 매우 많은 저장 공간과 처리 능력이 필요하다.
	- 데이터 저장소에서 삭제되거나 변경되는 것이 하나도 없다. CRUD가 아니라 CR만 수행함
	- 데이터 저장소에서 변경과 삭제가 전혀 발생하지 않으니 동시 업데이트 문제가 일어나지 않는다.
	- 저장 공간과 처리 능력이 충반하다면 애플리케이션이 완전한 불변성, 완전한 함수형으로 만들 수 있다.
	- 소스 코드 버전 관리 시스템이 정확히 이 방식으로 동작한다.
- 결론
	- 요약
		- 구조적 프로그래밍은 제어흐름의 직접적인 전환에 부과되는 규율이다.
		- 객체 지향 프로그래밍은 제어흐름의 간접적인 전환에 부과되는 규율이다.
		- 함수형 프로그래밍은 변수 할당에 부과되는 규율이다.
	- 소프트웨어의 핵심은 항상 그대로다.
		- 순차, 분기, 반복, 참조

## 3부 설계 원칙
- SOLID 원칙의 목적은 중간 수준의 소프트웨어 구조가 아래와 같도록 만드는 데 있다.
	- 변경에 유연하다.
	- 이해하기 쉽다.
	- 많은 소프트웨어 시스템에 사용될 수 있는 컴포넌트의 기반이 된다.
- '중간수준'이라 함은 프로그래머가 이들 원칙을 모듈 수준에서 작업할 때 적용할 수 있다는 뜻이다. 즉, 코드 수준보다는 조금 상위에서 적용되며 모듈과 컴포넌트 내부에서 사용되는 소프트웨어 구조를 정의하는데 도움을 준다.
- SOLID 원칙의 대략적인 설명
	- SRP: 단일 책임 원칙
		- 각 소프트웨어 모듈은 변경의 이유가 하나, 단 하나여야만 한다.
	- OCP: 개방-폐쇄 원칙
		- 기존 코드를 수정하기보다는 반드시 새로운 코드를 추가하는 방식으로 시스템의 행위를 변경할 수 있도록 설계해야만 소프트웨어 시스템을 쉽게 변경할 수 있다는 것이 요지이다.
	- LSP: 리스코프 치환 원칙
		- 상호 대체 가능한 구성요소를 이용해 소프트웨어 시스템을 만들 수 있으려면, 이들 구성요소는 반드시 서로 치환 가능해야 한다는 계약을 반드시 지켜야 한다.
	- ISP: 인터페이스 분리 원칙
		- 이 원칙에 따르면 소프트웨어 설계자는 사용하지 않은 것에 의존하지 않아야 한다.
	- DIP: 의존성 역전 원칙
		- 고수준 정책을 구현하는 코드는 저수준 세부사항을 구현하는 코드에 절대로 의존해서는 안된다. 대신 세부사항이 정책에 의존해야 한다.

### 7장 SRP: 단일 책임 원칙
- 모든 모듈이 단 하나의 일만 해야한다는 의미로 오해하지 말자. 이 원칙은 함수에 적용되는 원칙이다.
- SRP의 최종 버전은 다음과 같다.
	- 하나의 모듈은 하나의, 오직 하나의 액터에 대해서만 책임져야 한다.
- 모듈이란? 가장 단순한 정의는 바로 소스 파일이다. (또는 함수와 데이터 구조로 구성된 응집된 집합)
- SRP를 위반하는 징후들
	- 징후 1: 우발적 중복
		- Employee 클래스 안에 calculatePay(), reportHours(), save() 메서드가 있다.
		- 이 클래스는 회계팀->calculatePay(), 인사팀->reportHours(), DB관리자->save() 메서드를 사용한다.
		- 예를들어 편의를 위해 초과 근무를 제외한 업무 시간을 계산하는 regularHours()라는 메서드를 회계팀->calculatePay(), 인사팀->reportHours()메서드가 함께 공유한다고 하자.
		- 이경우 회계팀에서 요구사항이 들어와 regularHours()를 수정했을 때, 잘못된 데이터로 인해 수백만 달러의 예산을 지출한 인사팀의 격노를 경험할 수 있다.
		- SRP는 서로 다른 액터가 의존하는 코드를 서로 분리하라고 말한다.
	- 징후 2: 병합
		- DB관리자, 인사팀의 요구사항으로 인해 두 명의 서로 다른 개발자가, 다른 Employee 클래스를 수정한다고 했을 때 변경사항은 서로 충돌한다. 결과적으로 병합이 발생하여 위험이 따른다.
		- 이 문제를 벗어나는 방법은 서로 다른 액터를 뒷받침하는 코드를 서로 분리하는 것이다.
		- 해결책은 다양한데, 그 모두가 메서드를 각기 다른 클래스로 이동시키는 방식이다.
			- 아마도 가장 확실한 해결책은 데이터와 메서드를 분리하는 방식이다.
				- 즉 아무런 메서드가 없는 간단한 데이터 구조 EmployeeData 클래스를 만들고, 세 클래스가 공유하도록 한다. 세 클래스는 서로의 존재를 모르고, '우연한 중복'을 피할 수 있다.
			- 반면 위 해결책은 개발자가 세 가지 클래스를 인스턴스화하고 추적해야 한다는 게 단점이다. 이러한 난관에서 빠져나올 때 흔히 쓰는 기법으로 파서드(Facade) 패턴이 있다.
				- EmployeeFacade에 코드는 거의 없고, 이 클래스는 세 클래스의 객체를 생성하고, 요청된 메서드를 가지는 객체로 위임하는 일을 책임진다.
	- 결론
		- 단일 책임 원칙은 메서드와 클래스 수준의 원칙이다. 하지만 이보다 상위의 두 수준에서도 다른 형태로 다시 등장한다. 컴포넌트 수준에서는 공통 폐쇄 원칙이 된다. 아키텍처 수준에서는 아키텍처 경계의 생성을 책임지는 변경의 축이 된다.

### 8장 OCP: 개방-폐쇄 원칙
- 소프트웨어 개체는 확장에는 열려 있어야 하고, 변경에는 닫혀 있어야 한다.
- 다시 말해 소프트웨어 개체의 행위는 확장할 수 있어야 하지만, 이때 개체를 변경해서는 안 된다.
- 결론
	- OCP는 시스템의 아키텍처를 떠받치는 원동력 중 하나다. OCP의 목표는 시스템을 확장하기 쉬운 동시에 변경으로 인해 시스템이 너무 많은 영향을 받지 않도록 하는 데 있다.
	- 이러한 목표를 달성하려면 시스템을 컴포넌트 단위로 분리하고, 저수준 컴포넌트에서 발생한 변경으로부터 고수준 컴포넌트를 보호할 수 있는 형태의 의존성 계층구조가 만들어지도록 해야 한다.

### 9장 LSP: 리스코프 치환 원칙
- S 타입의 객체 o1 각각에 대응하는 T 타입 객체 o2가 있고, T 타입을 이용해서 정의한 모든 프로그램 P에서 o2의 자리에 o1을 치환하더라도 P의 행위가 변하지 않는다면, S는 T의 하위 타입이다.
- 결론
	- LSP는 아키텍처 수준까지 확장할 수 있고, 반드시 확장해야만 한다. 치환 가능성을 조금이라도 위배하면 시스템 아키텍처가 오염되어 상당량의 별도 메커니즘을 추가해야 할 수 있기 때문이다.

### 10장 ISP: 인터페이스 분리 원칙
- 의존성으로 인해 관련이 없는 코드의 변경이 있더라도 재컴파일, 재배포가 일어날 수 있다.
- 오퍼레이션을 인터페이스 단위로 분리하여 해결이 가능하다.
- 결론
	- 불필요한 짐을 실은 무언가에 의존하면 예상치도 못한 문제에 빠진다.

### 11장 DIP: 의존성 역전 원칙
- 의존성 역전 원칙에서 말하는 '유연성이 극대화된 시스템'이란 소스 코드 의존성이 추상에 의존하며 구체에는 의존하지 않는 시스템이다.
- 안정된 추상화
	- 변동성이 큰 구체 클래스를 참조하지 말라
		- 대신 추상 인터페이스를 참조하라
		- 이 규칙은 객체 생성 방식을 강하게 제약하며, 일반적으로 추상 팩토리를 사용하도록 강제한다.
	- 변동성이 큰 구체 클래스로부터 파생하지 말라
		- 정적 타입언어에서 상속은 소스 코드에 존재하는 모든 관계 중에서 가장 강력한 동시에 뻣뻣해서 변경하기 어렵다.
		- 따라서 상속은 아주 신중하게 사용해야 한다.
	- 구체 함수를 오버라이드 하지 말라
		- 대체로 구체 함수는 소스 코드 의존성을 필요로 하기 때문에, 구체 함수를 오버라이드 하면 이러한 의존성을 제거할 수 없게 되며, 실제로는 그 의존성을 상속하게 된다.
		- 이러한 의존성을 제거하려면, 차라리 추상 함수로 선언하고 구현체들에서 각자의 용도에 맞게 구현해야 한다.
	- 구체적이며 변동성이 크다면 절대로 그 이름을 언급하지 말라.
		- 이 실천법은 DIP 원칙을 다른 방식으로 풀어쓴 것이다.
- 팩토리
	- 이 규칙들을 준수하려면 변동성이 큰 구체적인 객체는 특별히 주의해서 생성해야 한다.
	- 대다수의 객체 지향 언어에서 바람직하지 못한 의존성을 처리할 때 추상 팩토리를 사용하곤 한다.
- 결론
	- DIP는 아키텍처 다이어그램에서 가장 눈에 드러나는 원칙이 될 것이다.

## 4부 컴포넌트 원칙
- SOILD 원칙이 벽과 방에 벽돌을 배치하는 방법을 알려준다면, 컴포넌트 원칙은 빌딩에 방을 배치하는 방법을 설명해준다.
- 4부에서는 소프트웨어 컴포넌트가 무엇인지, 컴포넌트를 구성하는 요소는 무엇인지 알아보고, 컴포넌트를 결합하여 시스템을 구성하는 방법에 대해 논의한다.

### 12장 컴포넌트
- 컴포넌트는 배포 단위다. 컴포넌트는 시스템의 구성 요소로 배포할 수 있는 가장 작은 단위다.
- 자바의 경우 jar 파일이 컴포넌트, 닷넷에서는 DLL이다. 컴파일형 언어에서 컴포넌트는 바이너리 파일의 결합체다.
- 여러 컴포넌트를 서로 링크하여 실행 가능한 단일 파일로 생성할 수 있다. 또는 컴포넌트 각각을 .jar나 .dll같이 동적으로 로드할 수 있는 플러그인이나 .exe 파이롤 만들어서 독립적으로 배포할 수 있다.
- 컴포넌트가 마지막에 어떤 형태로 배포되든, 잘 설계된 컴포넌트라면 반드시 독립적으로 배포 가능한, 따라서 독립적으로 개발 가능한 능력을 갖춰야 한다.
- 결론
	- 런타임에 플러그인 형태로 결합할 수 있는 동적 링크 파일이 이 책에서 말하는 소프트웨어 컴포넌트에 해당한다. 과거에는 초인적인 능력을 들여야하만 플러그인 아키텍처를 적용할 수 있었지만, 이제는 기본으로 쉽게 사용할 수 있는 지점까지 다다랐다.

### 13장 컴포넌트 응집도
- 컴포넌트 응집도와 관련된 세 가지 원칙이 있다.
	- REP(Reuse/Release Equivalence Principle): 재사용/릴리스 등가 원칙
		- 재사용 단위는 릴리스 단위와 같다.
		- 하나의 컴포넌트로 묶인 클래스와 모듈은 반드시 함께 릴리스할 수 있어야 한다.
	- CCP(Common Closure Principle): 공통 폐쇄 원칙
		- 동일한 이유로 동일한 시점에 변경되는 클래스를 같은 컴포넌트로 묶어라. 서로 다른 시점에 다른 이유로 변경되는 클래스는 다른 컴포넌트로 분리하라.
		- 이 원칙은 단일 책임 원칙(SRP)을 컴포넌트 관점에서 다시 쓴 것이다.
		- CCP는 변경될 가능성이 있는 클래스는 모두 한곳으로 묶을 것을 권한다. 이를 통해 릴리스, 재검증, 배포하는 일과 관련된 작업량을 최소화할 수 있다.
	- CRP(Common Reuse Principle): 공통 재사용 원칙
		- 컴포넌트 사용자들을 필요하지 않는 것에 의존하게 강요하지 말라.
		- CRP는 인터페이스 분리 원칙(ISP)의 포괄적인 버전이다. CRP는 사용하지 않는 클래스를 가진 컴포넌트에 의존하지 말라고 조언한다. 이 두 원칙은 한 문장으로 요약할 수 있다.
		- 필요하지 않은 것에 의존하지 말라
- 컴포넌트 응집도에 대한 균형 다이어그램
	- 프로젝트 초기에는 유지보수성에 중점을 두고 재사용성은 중요도를 낮추자
	- 프로젝트가 진행 될 수록 점차 유지보수성보다 재사용성에 중점을 둔다.

### 14장 컴포넌트 결합
- 지금부터 다룰 세 가지 원칙은 컴포넌트 사이의 관계를 설명한다.
- ADP: 의존성 비순환 원칙
	- 컴포넌트 의존성 그래프에 순환(cycle)이 있어서는 안 된다.
	- 하루 종일 일해서 무언가를 만들고 퇴근했는데, 이튿날 출근해 보면 전혀 돌아가지 않는 경험을 해본 적이 있는가? 왜냐하면 누군가가 더 늦게까지 일하면서 당신이 의존하고 있던 무언가를 수정했기 때문이다. (숙취 증후군)
	- 이 문제의 해결책은 두가지이다.
		- 주 단위 빌드(Weekly Build)
			- 중간 규모의 프로젝트에서는 흔하게 사용 된다.
			- 먼저 모든 개발자는 일주일의 첫 4일 동안은 서로를 신경 쓰지 않고, 어떻게 통합할지 걱정하지 않는다. 그런 후 금요일이 되면 변경된 코드를 모두 통합하여 시스템을 빌드한다.
			- 안타깝게도 프로젝트가 커지면 프로젝트 통합은 금요일 하루만에 끝마치는게 불가능해진다. 개발보다 통합에 드는 시간이 늘어나면서 팀의 효율성도 서서히 나빠진다.
		- 순환 의존성 제거하기
			- 이 문제의 해결책은 개발 환경을 릴리스 가능한 컴포넌트 단위로 분리하는 것이다.
			- 이를 통해 컴포넌트는 개별 개발자 또는 단일 개발팀이 책임질 수 있는 작업 단위가 된다.
			- 이 절차가 성공적으로 동작하려면 컴포넌트 사이의 의존성 구조를 반드시 관리해야 한다. 의존성 구조에 순환이 있어서는 안 된다. 순환이 생기면 '숙취 증후군'을 피해 갈 수 없다.
			- 컴포넌트 다이어그램에서 어느 컴포넌트에서 시작하더라도, 의존성 관계를 따라가면서 최초의 컴포넌트로 되돌아갈 수 없어야 한다.
		- 순환이 컴포넌트 의존성 그래프에 미치는 영향
			- 순환이 이루어지면 순환하는 여러개의 컴포넌트가 사실상 하나의 거대한 컴포넌트가 되어 버린다.
			- 이 컴포넌트 중 어느 것을 개발하더라도 '숙취 증후군'에 떠는 경험을 하게 될 것이다.
		- 순환 끊기
			- 의존성 역전 원칙 적용
			- 두 컴포넌트가 의존하는 새로운 컴포넌트를 만든다. 의존하는 클래스들을 새로운 컴포넌트로 이동시킨다.
		- 흐트러짐
			- 두 번째 해결책에서 시사하는 바는 요구사항이 변경되면 컴포넌트 구조도 변경될 수 있다는 사실이다.
			- 실제로 애플리케이션이 성장함에 따라 컴포넌트 의존성 구조는 서서히 흐트러지며 또 성장한다. 따라서 의존성 구조에 순환이 발생하는지를 항상 관찰해야 한다.
			- 순환이 발생하면 어떤 식으로든 끊어야 한다. 이 말은 때론 새로운 컴포넌트를 생성하거나 의존성 구조가 더 커질 수도 있음을 의미한다.
- 하향식(top-down) 설계
	- 지금까지 논의로 우리는 피할 수 없는 결론에 다다르게 된다. 즉, 컴포넌트 구조는 하향식으로 설계될 수 없다. 컴포넌트는 시스템에서 가장 먼저 설계할 수 있는 대상이 아니다.
	- 