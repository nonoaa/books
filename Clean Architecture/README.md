# Clean Architecture
## 1부 소개
### 1장 설계와 아키텍처란?
- 설계(design)와 아키텍처(architecture)가 무엇인가?
    - 아키텍처는 저수준의 세부사항과는 분리된 고수준의 무언가를 가리킬 때 흔히 사용
    - 설계는 저수준의 구조 또는 결정사항 등을 의미할 때가 많다.
    - 하지만 아키텍트가 실제로 하는 일을 살펴보면 이러한 구분은 무의미
- 이러한 의사결정의 목표는?
    - 소프트웨어 아키텍처의 목표는 필요한 시스템을 만들고 유지보수하는 데 투입되는 인력을 최소화하는 데 있다.
- 결론
    - 개발 조직이 할 수 있는 최고의 선택지는 조직에 스며든 과신을 인지하여 방지하고, 소프트웨어 아키텍처의 품질을 심각하게 고민하기 시작하는 것이다.

### 2장 두 가지 가치에 대한 이야기
- 모든 소프트웨어 시스템은 이해관계자에게 행위(behavior), 구조(structure) 두 가지 가치를 제공한다. 두 가치를 모두 반드시 높게 유지해야 한다.
- 행위
    - 프로그래머를 고용하는 이유는 이해관계자를 위해 기계가 수익을 창출하거나 비용을 절약하도록 만들기 위해서다.
    - 이를 위해 프로그래머는 이해관계자가 기능 명세서나 요구사항문서를 구체화할 수 있도록 돕는다. 그리고 이해관계자의 기계가 이러한 요구사항을 만족하도록 코드를 작성한다.
    - 기계가 이러한 요구사항을 위반하면, 프로그래머는 디버거를 열고 문제를 고친다.
    - 많은 프로그래머가 이러한 활동이 자신이 해야 할 일의 전부라고 생각한다.
- 아키텍처
    - 소프트웨어는 반드시 부드러워야 한다.(변경사항을 간단하고 쉽게 적용할 수 있어야 한다.)
    - 아키텍처가 특정 형태를 다른 형태보다 선호하면 할수록, 새로운 기능을 이 구조에 맞추는 게 더 힘들어진다.
    - 따라서 아키텍처는 형태에 독립적이어야 하고, 그럴수록 더 실용적이다.
- 아이젠하워 매트릭스
    1. 긴급하고 중요한
    2. 긴급하지는 않지만 중요한
    3. 긴급하지만 중요하지 않은
    4. 긴급하지도 중요하지도 않은
    - 아키텍처, 즉 중요한 일은 이 항목의 가장 높은 두 순위를 차지하지만, 행위는 첫 번째와 세 번째에 위치한다.
    - 업무 관리자와 개발자가 흔하게 저지르는 실수는 세 번째에 위치한 항목을 첫 번째로 격상시켜 버리는 일이다. 이러한 실수로 인해 시스템에서 중요도가 높은 아키텍처를 무시한 채 중요도가 떨어지는 기능을 선택하게 된다.
- 아키텍처를 위해 투쟁하라
    - 개발팀은 회사에서 가장 중요하다고 스스로 믿는 가치를 위해 투쟁해야 한다.
    - 아키텍처가 후순위가 되면 시스템을 개발하는 비용이 더 많이 들고, 일부 또는 전체 시스템에 변경을 가하는 일이 현실적으로 불가능해진다.

## 2부 벽돌부터 시작하기: 프로그래밍 패러다임
### 3장 패러다임 개요
- 이 장에서는 세가지 패러다임인 구조적 프로그래밍, 객체지향 프로그래밍, 함수형 프로그래밍에 대해 설명한다.
- 구조적 프로그래밍
    - 최초로 적용된 패러다임
    - Dijkstra는 무분별한 점프(goto 문장)는 프로그램 구조에 해롭다는 사실을 제시했다.
    - Dijkstra는 이러한 점프들을 if/then/else, do/while/until과 같이 더 익숙한 구조로 대체했다.
    - 요약
        - 구조적 프로그래밍은 제어흐름에 직접적인 전환에 대해 규칙을 부과한다.
- 객체 지향 프로그래밍
    - 두번째로 도입된 패러다임
    - 요한 달과 크리스텐 니가드는 알골(ALGOL) 언어의 함수 호출 스택 프레임을 힙으로 옮기면, 함수 호출이 반환된 이후에도 함수에서 선언된 지역 변수가 오랫동안 유지될 수 있음을 발견했다. 이러한 함수가 클래스의 생성자가 되었고, 지역 변수는 인스턴스 변수, 중첩 함수는 메서드가 되었다.
    - 요약
        - 객체 지향 프로그래밍은 제어흐름의 간접적인 전환에 대해 규칙을 부과한다.
- 함수형 프로그래밍
    - 세 번째 패러다임은 최근에 들어서야 겨우 도입되기 시작했지만, 세 패러다임중 가장 먼저 만들어졌다.
    - 함수형 프로그래밍은 람다 계산법의 연구 결과에 직접적인 영향을 받아 만들어졌다.
    - 람다 계산법의 기초가 되는 개념은 불변성으로, 심볼의 값이 변경되지 않는다는 개념이다.
    - 요약
        - 함수형 프로그래밍은 할당문에 대해 규칙을 부과한다.
- 생각할 거리
    - 각 패러다임은 프로그래머에게서 권한을 박탈한다.
    - 어느 패러다임도 새로운 권한을 부여하지 않는다.
    - 즉 무엇을 해서는 안 되는지를 말해준다.
    - 이 패러다임들은 1958년~1968년에 걸쳐서 만들어졌고, 이후 새롭게 등장한 패러다임은 없다.
- 결론
    - 세 가지 패러다임과 아키텍처의 세 가지 큰 관심사(함수, 컴포넌트 분리, 데이터 관리)가 어떻게 서로 연관되는지에 주목하자.

### 4장 구조적 프로그래밍
- 다익스트라는 프로그램을 순차, 분기, 반복이라는 세가지 구조만으로 표현할 수 있다는 사실을 증명했다.
- 다익스트라가 "goto문의 해로움"이라는 편지를 보냈고, 승리했다.
- 테스트
    - 다익스트라는 "테스트는 버그가 있음을 보여줄뿐, 버그가 없음을 보여줄 수는 없다"라고 말한 적이 있다.
    - 다시 말해 프로그램이 잘못되었음을 테스트를 통해 증명할 수는 있지만, 프로그램이 맞다고 증명할 수는 없다.
    - 이 사실은 소프트웨어 개발이 수학적인 구조를 다루는 듯 보이더라도, 수학적인 시도가 아니라는 사실을 담고 있다.
    - 제약 없는 goto문을 사용하는 등의 이유로 입증이 불가능한 프로그램은 테스트를 아무리 많이 수행하더라도 절대로 올바르다고 볼 수 없다.
- 결론
    - 구조적 프로그래밍이 오늘날까지 가치 있는 이유는 프로그래밍에서 반증 가능한 단위를 만들어 낼 수 있는 바로 이 능력 때문이다. 또한 흔히 현대적 언어가 아무런 제약없는 goto 문장은 지원하지 않는 이유이기도 하다. 뿐만 아니라 아키텍처 관점에서는 기능적 분해를 최고의 실천법 중 하나로 여기는 이유이기도 하다.

### 5장 객체 지향 프로그래밍
- 캡슐화?
    - C언어에서도 완벽한 캡슐화가 가능하다.
    - 이후 C++라는 형태로 OO가 등장했고, C가 제공하던 완전한 캡슐화가 깨지게 되었다.
        - 언어에 public, private, protected 키워드를 도입함으로써 불완전한 캡슐화를 사실상 어느 정도 보완하기는 했으나, 임시방편일 뿐이다.
    - OO가 강력한 캡슐화에 의존한다는 정의는 받아들이기 힘들다. 실제로 많은 OO언어가 캡슐화를 거의 강제하지 않는다.
    - OO 프로그래밍은 프로그래머가 충분히 올바르게 행동함으로써 캡슐화된 데이터를 우회해서 사용하지 않을 거라는 믿음을 기반으로 한다. 하지만 OO언어들이 실제로는 C언어에서 누렸던 완벽한 캡슐화를 약화시켜 온 것은 틀림없다.
- 상속?
    - OO언어가 더 나은 캡슐화를 제공하진 못했지만 상속만큼은 확실히 제공했다.
    