# Test Driven Development : By Example
## 들어가는 글
- 테스트 주도 개발 규칙
	- 오직 자동화된 테스트가 실패할 경우에만 새로운 코드를 작성한다.
	- 중복을 제거한다.
## 1부 화폐 예제
- TDD의 리듬을 요약하면 다음과 같다.
	1. 재빨리 테스트를 하나 추가한다.
	2. 모든 테스트를 실행하고 새로 추가한 것이 실패하는지 확인한다.
	3. 코드를 조금 바꾼다.
	4. 모든 테스트를 실행하고 전부 성공하는지 확인한다.
	5. 리팩토링을 통해 중복을 제거한다.
### 1장. 다중 통화를 지원하는 Money 객체
- 새로운 보고서 예시
	- $5 + 10CHF = $10(환율이 2:1일 경우)
	- **$5 x 2 = $10**
- 이 새로운 보고서를 생성하려면 어떤 기능들이 있어야 할까?
	- 통화가 다른 두 금액을 더해서 주어진 환율에 맞게 변한 금액을 결과로 얻을 수 있어야 한다.
	- 어떤 금액(주가)을 어떤 수(주식의 수)에 곱한 금액을 결과로 얻을 수 있어야 한다.
- **먼저 할일**은 굵은 글씨체로 나타내고, ~~작업을 끝낸 항목~~에는 취소선으로 나타내자. 예시에서 볼 수 있듯이 곱하기를 먼저 다룰 생각이다.
- 간단한 곱셈 테스트 예
	-	```java
		public void testMultiplication() {
			Dollar five = new Dollar(5);
			five.times(2);
			assertEquals(10, five.amount);
		}
		```
	- 발생한 문제들
		- amount를 private으로 만들기
		- Dollar 부작용?
		- Money 반올림?
	- 간단한 테스트를 만든 뒤, 어떻게든 컴파일 문제 해결하기 -> 어떻게든 테스트 성공 시키기 -> 중복 코드 제거하기 과정을 반복.
	- 위 과정에서 수행한 작업
		- 우리가 알고 있는 작업해야 할 테스트 목록을 만듬
		- 오퍼레이션이 외부에서 어떻게 보이길 원하는지 말해주는 이야기를 코드로 표현
		- JUnit에 대한 상세한 사항들은 잠시 무시
		- 스텁 구현을 통해 테스트를 컴파일
		- 끔찍한 죄악을 범하여 테스트를 통과시킴
		- 돌아가는 코드에서 상수를 변수로 변경하여 점진적으로 일반화
		- 새로운 할일들을 한번에 처리하는 대신 할일 목록에 추가하고 넘어감

### 2장. 타락한 객체
- 일반적인 TDD 주기는 다음과 같다.
	1. 테스트를 작성한다.
	2. 실행 가능하게 만든다.
		- 가장 중요한 것은 빨리 초록 막대를 보는 것이다.
	3. 올바르게 만든다.
		- 이제 시스템이 작동하므로 직전에 저질렀던 죄악을 수습하자.
- 문제점 리스트
	- $5 + 10CHF = $10(환율이 2:1일 경우)
	- ~~$5 x 2 = $10~~
	- amount를 private으로 만들기
	- **Dollar 부작용?**
	- Money 반올림?
- 테스트를 통과했지만 뭔가 이상하다. Dollar에 대해 연산을 수행한 후에 해당 Dollar의 값이 바뀌는 점이다.
	- 다음과 같이 쓸 수 있기를 원한다.
	-	```java
		public void testMultiplication() {
			Dollar five = new Dollar(5);
			five.times(2);
			assertEquals(10, five.amount);
			five.times(3);
			assertEquals(15, five.amount);
		}
		```
	- 테스트와 Dollar을 다음과 같이 수정한다.
	-	```java
		public void testMultiplication() {
			Dollar five = new Dollar(5);
			Dollar product = five.times(2);
			assertEquals(10, product.amount);
			product = five.times(3);
			assertEquals(15, product.amount);
		}
		```
	-	```java
		Dollar times(int multiplier) {
			return new Dollar(amount * multipliler);
		}
		```
- 1장에서는 테스트를 통과하기 위해 일단 가짜 구현으로 시작해서 점차 실제 구현을 만들어갔다. 하지만 이번에는 올바른 구현이라고 생각한 내용을 입력한 후 테스트가 실행되는 동안 기도했다.
- 다음은 최대한 빨리 초록색을 보기 위해 취할 수 있는 전략이다.
	- 가짜로 구현하기 : 상수를 반환하게 만들고 진짜 코드를 얻을 때까지 단계적으로 상수를 변수로 바꾸어 간다.
	- 명백한 구현 사용하기 : 실제 구현을 입력한다.
- 모든 일이 자연스럽게 잘 진행되고 내가 뭘 입력해야 할지 알 때는 명백한 구현을 더해 나간다. 예상치 못한 빨간 막대를 만나게 되면 뒤로 한발 물러서서 가짜로 구현하기 방법을 사용하면서 올바른 코드로 리팩토링한다. 그러다 다시 자신감을 되찾으면 명백한 구현 사용하기 모드로 돌아온다.

### 3장
- 요약
	- 우리의 디자인 패턴(값 객체)이 하나의 또 다른 오퍼레이션을 암시한다는 걸 알아챘다.
	- 해당 오퍼레이션을 테스트했다.
	- 해당 오퍼레이션을 간단히 구현했다.
	- 곧장 리팩토링하는 대신 테스트를 조금 더 했다.
	- 두 경우를 모두 수용할 수 있도록 리팩토링했다.