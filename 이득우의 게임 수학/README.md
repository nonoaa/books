# 이득우의 게임 수학
## 1부 가상 세계의 구축
### 2장 수: 가상 세계를 구성하는 가장 작은 단위
#### 2.1 수와 집합
- 수집합
	- 자연수: 물건을 세거나 순서를 지정하기 위해 사용하는 수의 집합
	- 정수: 자연수와 자연수의 음수 0을 포함하는 수의 집합
	- 유리수: 분모가 0이 아닌 두 정수의 비율 혹은 분수로 나타낼 수 있는 수의 집합
	- 무리수: 두 정수 비 혹은 분수로 나타낼 수 없는 수의 집합
	- 실수: 유리수와 무리수를 포함하는 수의 집합
	- 복소수: 실수와 제곱하면 -1이 되는 허수 단위 i를 조합해 a + bi(a,b는 실수) 형태로 표현하는 수의 집합
	- 사원수: 실수와 제곱하면 -1이 되는 세 허수 단위 i, j, k를 조합해 a + bi + cj + dk(a,b,c,d는 실수) 형태로 표현하는 수의 집합
- 연산과 수의 구조
	- 이항 연산의 성질
		- 닫혀 있음: 어떤 집합에서 두 원소를 사용한 이항연산의 결과가 항상 그 집합에 속하는 성질
		- 교환법칙: 두 원소의 좌우 순서를 바꿔도 결과가 동일한 성질
		- 결합법칙: 세 원소의 연산 순서를 바꿔도 결과가 동일한 성질
		- 분배법칙: 두 이항연산에 대해 a · (b + c) = a · b + a · c 와 (b + c) · a = b · a + c · a의 결과가 나오는 성질
		- 항등원(Identity): 주어진 원소와의 이항연산 결과가 언제나 주어진 원소가 되는 특별한 원소. 실수에서 덧셈의 항등원은 0이고 곱셈의 항등원은 1이다.
		- 역원(Inverse): 주어진 원소와의 이항연산 결과가 언제나 항등원이 되는 특별한 원소. 실수에서 덧셈의 역원은 반대수, 곱셈의 역원은 역수라고 부른다.
#### 2.2 함수
- 함수의 개념과 종류
	- 함수에서 왼쪽에 위치한 첫 번째 집합을 정의역(input)이라 하고, 오른쪽에 위치한 두 번째 집합을 공역(output)이라 한다.
	- 공역의 모든 원소가 정의역에 대응될 필요는 없기 때문에 정의역에 대응되는 공역의 원소만 따로 모아 부분집합을 형성할 수 있는데, 이를 치역이라고 한다.
	- 전사함수(Surjection)
		- 모든 요소가 정의역에 대응되는 함수 (공역과 치역이 동일한 함수)
	- 단사함수(Injection)
		- 일대일 함수라고도 부름
		- 정의역과 공역의 요소가 일대일로 대응되는 함수
	- 전단사함수(Bijection)
		- 정의역과 공역의 모든 요소가 빠짐없이 일대일로 대응되는 함수
- 합성함수
	- 함수의 대응관계를 확장해 다수 집합의 대응 관계로 발전시킬 수도 있다.
	- g ∘ f 또는 g(f(x))로 표시한다.
		- 먼저 실행되는 함수가 ∘기호 오른쪽에 놓인다는 점에 유의
		- g ∘ f 는 g 써클 f로 부른다.
- 항등함수와 역함수
	- 항등원, 역원과 동일한 개념이 함수에도 존재한다.
	- 정의역과 공역이 동일한 값으로 대응되는 함수를 항등함수(Identity function)이라 하고 기호 id로 나타낸다.
	- 어떤 함수와 역함수(Inverse function)를 합성한 결과는 언제나 항등함수가 된다.
- 곱집합을 활용한 좌표 평면으로의 확장
	- 곱집합(Cartesian product, or Product set)이란 두 집합의 원소를 순서쌍으로 묶은 원소의 집합을 의미한다.
	- A x B 와 같이 표현
	- 두 실수 집합의 곱집합으로 평면을 표현할 수 있고 다시 실수 집합을 곱집합으로 설정하면 3차원 공간이 된다.

### 3장 벡터: 가상 공간의 탄생
#### 3.1 데카르트 좌표계
- 데카르트 좌표계의 한 원소는 곱집합과 동일하게 순서쌍으로 표현하며 좌표(coordinate)라고 부른다. (x, y)

#### 3.2 벡터 공간과 벡터
- 스칼라와 벡터
	- 두 개 이상의 실수를 곱집합으로 묶어 형성된 집합을 공리적 집합론의 관점에서 규정한 것을 벡터 공간(Vector space)이라고 하며, 벡터 공간의 원소를 벡터(Vector)라고 한다.
	- 좌푯값으로 사용하는 x와 y를 실수로 규정하기보다는 체의 구조를 지니는 집합, 즉 체 집합의 원소로 규정한다. 이렇게 체의 구조를 가지는 수 집합의 원소를 스칼라(Scalar)라고 부른다.
- 벡터 공간의 연산
	- 공리적 집합론의 관점에서 정의된 벡터 공간은 두 가지 기본 연산이 존재한다. 사용되는 수 a,x,y는 모두 체 집합의 원소인 스칼라다.
		- 벡터와 벡터의 덧셈(벡터의 합)
			- v1 + v2 = (x1, y1) + (x2, y2) = (x1 + x2, y1 + y2)
		- 스칼라와 벡터의 곱셈(줄여서 스칼라 곱셈이라 부름)
			- a · v = a · (x, y) = (a · x, a · y)
	- 벡터 공간의 공리
		1. 벡터의 합의 결합법칙: u + (v + w) = (u + v) + w
		2. 벡터의 합의 교환법칙: u + v = v + u
		3. 벡터의 합의 항등원: v + 0 = v
		4. 벡터의 합의 역원: v + (-v) = 0
		5. 스칼라 곱셈의 호환성: a(bv) = (ab)v
		6. 스칼라 곱셈의 항등원: 1 · v =  v
		7. 스칼라 곱셈과 벡터의 합에 대한 분배법칙: a(u + v) = au + av
		8. 스칼라 곱셈과 스칼라 덧셈에 대한 분배법칙: (a + b)v = av + bv
- 벡터의 크기와 이동
	- 벡터의 크기는 피타고라스의 정리를 이용해 구한다. |v|
	- 크기가 1인 벡터는 단위 벡터라고 한다.
	- 스칼라 곱셈의 성질을 이용해 임의의 벡터 v를 이의 크기인 |v|로 나누면 단위 벡터를 얻을 수 있다. 크기가 1인 단위 벡터로 다듬는 작업을 정규화한다고 부른다.

#### 3.3 벡터의 결합과 생성
- 선형 연산을 사용해 n개의 스칼라 a1, ..., an과 벡터 v1, ... vn을 결합해 새로운 벡터를 생성하는 수식을 선형 결합(Linear combination)이라고 한다.
	- a1v1 + a2v2 + a3v3 + ... + anvn = v'
- a1v1 + a2v2 + a3v3 + ... + anvn = 0
	- 2 · (1, 1) + (-1) · (2, 2) = (0, 0) 처럼 모든 a 값이 0이 아님에도 영벡터를 만들 수 있다면, 선형 결합에 사용된 벡터는 서로 '선형 종속의 관계'를 가진다라고 표현한다.
	- 따라서 (1, 1)과 (2, 2)의 두 벡터는 선형 종속인 관계를 갖는다.
	- 반면 영벡터가 나오기 위해서 모든 a값이 0이어야 한다면 선형 결합에 사용된 벡터들은 서로 '선형 독립의 관계'를 가진다라고 표현한다.
	- 0 · (1, 2) + 0 · (2, 1) = (0, 0) 와 같이 (1, 2)와 (2, 1) 두 벡터가 결합할 때 영벡터가 나오려면 모든 스칼라 a의 값은 0이어야 하므로, 두 벡터는 선형 독립의 관계를 갖는다.
- 선형 독립의 관계를 가지는 벡터를 선형 결합하면 벡터 공간에 속한 모든 벡터를 생성할 수 있다.
- 평면의 모든 점을 생성하기 위한 선형 결합식에는 서로 평행하지 않은 2개의 벡터가 필요하다. 두 벡터는 선형 독릭의 관계를 가져야 한다.
- 선형 독립 관계를 가지는 벡터의 집합을 기저(Basis)라고 한다.
	- 기저에 속한 원소를 기저벡터(Basis Vector)라고 한다.

### 4장 삼각함수: 회전을 위한 수학
#### 4.1 삼각함수
- 길이가 1인 원의 임의의 점은 데카르트 좌표계로 좌표를 나타내면 (cosθ, sinθ)로 표현할 수 있다.
- 이를 피타고라스 정리 a^2 + b^2 = c^2에 대입하면 cos^2θ + sin^2θ = 1 이라는 공식을 얻을 수 있다. 이는 반지름 길이와 무관하게 동일하게 성립한다.
- 삼각함수의 성질
	1. sin함수와 cos함수는 항상 -1 에서 1 사이를 일정하게 반복하는 패턴을 띤다.
	2. sin함수와 cos함수의 값은 360° 주기로 반복된다.
	3. y축을 기준으로 좌우를 접어 포갰을 때 cos 함수 그래프는 데칼코마니처럼 좌우 대칭인 반면, sin 함수 그래프는 상하가 반전된 원점 대칭의 형태를 띤다. cos함수와 같이 좌우 대칭의 성질을 가진 함수를 짝함수(Even function) 또는 우함수라고 부르며, sin함수와 같이 원점 대칭의 성질을 가진 함수를 홀함수(Odd function) 또는 기함수라고 부른다.
		- sin함수와 cos함수가 지니는 홀함수와 짝함수의 성질은 다음과 같은 식으로 정리할 수 있다.
		- cos(-θ) = cos(θ)
		- sin(-θ) = -sin(θ)
	- tan 함수
		- sinθ / cosθ
		- cosθ가 0이되는 90°, 270°, -90°, -270°에서는 값이 존재하지 않는다.
		- 홀함수의 성질을 가진다.
- 호도법(Radian)
	- 벡터의 경우 크기를 비교하기 용이하도록 크기 1의 단위 벡터를 정의한 것처럼, 각을 측정할 때도 단위량 1을 기반으로 상대적인 크기를 측정할 수 있도록 체계를 만들면 합리적일 것이다.
	- 그래서 실무 계산에서 삼각함수를 응용할 때에는 각도법 대신 호의 길이를 기준으로 각을 측정하는 방법을 사용한다. 이를 호도법(Radian)이라 한다.
	- 호도법은 호의 길이가 1이 되는 부채꼴의 각을 기준으로 각을 측정한다.
	- 180°에 해당하는 반지름 1인 반원의 호 길이는 π이다. 거꾸로 호의 길이가 1인 부채꼴의 중심각을 1rad(라디안)dlek. 1라디안은 각도로 환산하면 약 57.2958도이며, 무리수이다.
	- 각도법과 호보법 사이에는 다음의 대응관계가 성립한다.
		- π(rad) = 180°
		- 1° = π/180 (rad)
		- 1(rad) = (180/π)°
	- 흔히 쓰는 각도와 호도 표기
		- 각도법	호도법
		- 30°		π/6
		- 45°		π/4
		- 60°		π/3
		- 90°		π/2
		- 180°		π
		- 360°		2π

#### 4.2 삼각함수를 활용한 물체의 회전
- 좌표 (1,1)이 각 0만큼 회전한 벡터v'의 좌표는 다음곽 같이 얻을 수 있다.
	- v' = (cos0 - sin0, sin0 + cos0)
	- 따라서 임의의 벡터 (x, y)가 각 0만큼 회전된 결과 (x', y')는 다음과 같다.
	- x' = xcos0 - ysin0
	- y' = xsin0 + ycos0

#### 4.3 삼각함수의 역함수
- y = f(x) = sin(x)
- sin함수가 가진 x와 y사이의 대응 관계를 살펴보면 정의역의 여러 요소가 공역의 한 요소에 대응되는 것을 알 수 있다.
- 만일 공역의 범위를 실수 집합 전체가 아닌 [-1, 1] 구간으로 한정해 정의한다면, sin함수는 전사함수의 성질을 띤다.
- 여기서 정의역의 범위를 좁혀 정의역의 한 요소가 공역의 한 요소에 대응되도록 전단사함수를 만들어보자. 이때 정의역의 범위는 [-90°, 90°] 구간이 된다.
- 이렇게 어떤 함수를 전단사함수로 만든다면 sinx값이 주어졌을 때 거꾸로 각 x를 구할 수 있는 역함수가 존재하게 된다. 이와 같이 정의역과 공역의 범위를 제한시켜 얻은 sin함수의 역함수를 arcsin(아크사인) 함수라고 부른다.
- f^-1(x) = sin^-1(x) = arcsin(x)
- cos, tan함수에 대한 역함수 또한 arccos(아크코사인), arctan(아크탄젠트)라고 부른다.
- arctan 함수는 벡터의 각도를 구하는 데 유용하게 사용된다. 임의의 벡터를 v = (x, y)라고 할때 tan 함수값 y/x을 arctan 함수에 넣으면 해당 벡터가 x축과 이루는 사잇각을 얻어낼 수 있다.
	- 그런데 3사분면에 있는 좌표의 경우에는 분수 y/x값을 arctan에 넣을 경우 정보를 얻을 수 없다.
	- 두 값이 가지는 부호를 파악하기 위해 x와 y값을 따로 전달해야 하기 때문에, arctan 함수는 두종류가 있으며 atan2 함수가 x와 y를 따로 전달하는 함수이다.

#### 4.4 극좌표계
- 데카르트 좌표계로 회전을 구현하면 회전에 따른 x와 y의 변화를 매번 계산하는 번거로움이 발생한다.
- 회전 동작을 기반으로 설계된 좌표계를 고안해 사용한다면, 이로부터 편리하게 회전을 관리하고 구현할 수 있을 것이다. 이를 위해 고안된 좌표계가 바로 극좌표계(Polar coordinate system)다.
- 극좌표계는 원점으로부터의 거리 r과 각0의 두 요소로 구성되며 극좌표계의 좌표는 (r, 0)로 표시한다.
- 데카르트 좌표계로 표현된 벡터 (x, y)는 벡터의 크기와 arctan 함수를 사용해 다음과 같이 극좌표계 (r, 0)로 변환할 수 있다.
	- r = √(x^2 + y^2)
	- 0 = atan2(y, x)
- 반대로 극좌표계의 좌표 (r, 0)를 데카르트 좌표계 (x, y)로 변환하는 식은 삼각함수를 사용해 구할 수 있다.
	- x = r cos0
	- y = r sin0
- 극좌표계가 지니는 원형 공간의 성질은 회전에 관련된 여러 효과를 줄 때 유용하게 사용된다. 예를 들어 롤의 스킬 아이콘 쿨타임 효과는 대표적인 극좌표계의 활용 예시다.

### 5장 행렬: 가상 세계의 변환 도구
#### 5.1 선형성: 예측 가능한 비례 관계
- 수학에서는 선형성을 다음과 같은 가법성(Additivity)과 1차 동차성(Homogeneity of degree 1) 두 가지 조건을 모두 만족하는 함수의 성질로 정의한다.
- y = ax 는 선형성을 만족, y = ax + b는 선형성을 만족하지 못 한다.
- 벡터 공간의 선형 변환
	- f(v) = f(x, y) = (ax + by, cx + dy) 함수는 가법성과 1차 동차성을 만족하여 선형 함수다.
	- 벡터 공간에서 발생하는 선형 변환의 원리는 크기 변환이나 회전 변환과 관련이 있다.
	- 벡터 v의 크기를 k배 늘리는 작업: f(v) = f(x, y) = (kx, ky)
	- 벡터 v를 각 0만큼 회전시키는 작업: f(v) = f(x, y) = (cos0x - sin0y, cos0x + sin0y)

#### 5.2 행렬
- 행렬의 기본 연산
	- 행렬과 행렬의 덧셈
		- A + B = [a b] + [e f] = [a+e b+f]<br>
		&emsp;&emsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[c d]&nbsp;&nbsp;&nbsp;[g h]&nbsp;&nbsp;&nbsp;[c+g d+h]
	- 행렬과 스칼라의 곱셈
		- k · A = k · [a b] = [k·a k·b]<br>
			&emsp;&emsp;&emsp;&emsp;&nbsp;[c d]&nbsp;&nbsp;&nbsp;[k·c k·d]
	- 행렬의 전치(Transpose of a matrix)
		- [a d]T<br>
		  [b e]&nbsp;&nbsp;=[a b c]<br>
		  [c f]&nbsp;&nbsp;&nbsp;&nbsp;[d e f]
	- 행렬과 행렬의 곱셈 (줄여서 행렬 곱)
		- [a b] · [e f] = [ae+bg af+bh]<br>
		  [c d]&nbsp;&nbsp;&nbsp;[g h]&nbsp;&nbsp;&nbsp;[ce+dg cf+dh]
		- 행렬 곱셈의 중요한 성질 중 하나는 교환법칙이 성립하지 않는다는 점이다. 순서를 바꿔 곱셈을 하면 다른 결과가 나온다.
		- 행렬은 다음과 같이 결합법칙을 만족한다. (A · B) · C = A · (B · C)
- 정방행렬의 곱셈
	- 2 X 2 정방행렬이 2차원 벡터 공간의 선형 변환에 대응된다면, 2 X 2 정방행렬 간의 곱은 2.2.2 절에서 다룬 합성함수에 대응되는 연산이다.
- 열 기준 행렬과 행 기준 행렬
	- 수학에서 행렬을 다룰 때는 벡터를 열벡터로 나타내는 열 기준 행렬 방식을 주로 사용한다.
	- 그런데 컴퓨터에서 실제로 행렬을 응용할 때는, 행 기준 행렬을 사용하는 경우도 있다. 행 기준으로 선형 변환을 수행할 때는 열 기준과 다르게 행렬과 위치를 거꾸로 뒤집어서, 다음과 같이 벡터를 앞쪽에 두어야 행렬의 곱셈이 성립된다.
		- [a b] · [x] = [ax + by]  -> [x y] · [a c] = [ax+by cx+dy]<br>
		  [c d]&nbsp;&nbsp;&nbsp;[y]&nbsp;&nbsp;&nbsp;[cx + dy]&emsp;&emsp;&emsp;&emsp;&nbsp;&nbsp;[b d]
	- 행 기준 방식을 사용하는 사례: DirectX, Unreal
	- 열 기준 방식을 사용하는 사례: 오픈 GL, Unity
	- 두 방식 모두 전치연산을 통해 서로 변환 가능하다.

#### 5.3 행렬의 설계
- 크기 변환행렬(Scale transformation matrix)
	- e1: (1,0), e2: (0,1)의 좌표를 갖는 두 표준기저벡터를 변환하는 크기 변환행렬은 다음과 같다.
		- S = [a 0]<br>
		&emsp;&nbsp;&nbsp;[0 b]
- 회전 변환행렬(Rotation transformation matrix)
	- 90° 회전 변환을 수행하는 행렬
		- R90° = Rπ/2 = [0 -1]<br>
		&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;[1 0]
	- -90° 회전 변환을 수행하는 행렬
		- R-90° = R-π/2 = [0 1]<br>
		&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;[-1 0]
	- 90° 회전의 구현
		- (x, y)의 값을 가지는 벡터v를 90°로 변환하는 작업은 행렬을 사용하지 않아도 두 값을 바꿔치는 방법으로 간단히 구현할 수 있다. 벡터 v를 시계반대 방향으로 90° 회전한 벡터 v는 두값을 바꾸고 첫 번째 요소에 음수를 부여해 얻을 수 있다.
			- v' = (-y, x)
		- 벡터 v를 시계 방향으로 90° 회전한 벡터
			- v' = (y, -x)
	- 각 0에 대한 회전 변환행렬
		- R0 = [cos0 -sin0]<br>
		&emsp;&emsp;[sin0 cos0]
- 전단 변환행렬
	- 이번에는 표준기저벡터 e1을 고정한 상태에서 표준 기저벡터 e2를 x축 방향으로 미는 변환을 생각해보자.
	- 표준기저벡터 e1은 고정되어 있기 때문에 변환된 결과는 대각선으로 밀리는 형태를 띤다.
	- 표준기저벡터 e2를 x축 방향으로 a만큼 밀어내는 전단 변환행렬은 다음과 같이 설계할 수 있다.
		- S = [1 a]<br>
		&emsp;&emsp;[0 1]

#### 5.4 역행렬
- 행렬은 함수와 마찬가지로 항등행렬(Identity matrix)와 역행렬(Inverse matrix)가 존재한다.
	- 항등행렬 I = [1 0]<br>
	&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;[0 1]
	- 역행렬 A · A^-1 = A^-1 · A = I
		- 역행렬을 시각적으로 나타낸다면 벡터 V가 선형 변환된 벡터 W를 다시 벡터 V로 되돌리는 선형 변환이라고 할 수 있다.
- 역행렬의 존재를 파악하는 행렬식
	- 어떤 함수가 역함수를 갖기 위한 조건은 전단사함수여야 함이다. 행렬도 함수이므로 두 공간의 변환이 전단사로 대응될 때만 역행렬이 존재한다.
	- 어떤 행렬이 역행렬이 존재하는 지 확인하는 수식을 행렬식이라고 한다. 기호는 det()로 표시한다.
	- A = [a b]/[c d]
	- det(A) = ad - bc
	- det(A)의 값이 0인 선형 변환은 전단사 대응이 성립하지 않아 역행렬이 존재하지 않는다.
	- 값이 0인 변환은 시각적으로 봤을 때 2차원의 평면 영역이 1차원의 직선 영역으로 압축되는 변환이다. 이렇게 차원이 줄어들어 원 공간의 정보가 소멸 되면 원래대로 되돌리는 것이 불가능해진다.
	- det의 원리: 평행사변형의 넓이를 구하는 공식. 0이 되면 못구함
- 크기 변환행렬의 역행렬
	- 크기 변환행렬 S = [a 0]/[0 b]의 역행렬 S^-1 = [1/a 0]/[0 1/b]
- 전단 변환행렬의 역행렬
	- S = [1 a]/[0 1], S^-1 = [1 -a]/[0 1]
- 회전 변환행렬의 역행렬
	- R0^-1 = R-0이다. sin함수와 cos함수는 다음과 같은 성질이 있다.
		- cos(-0) = cos(0)
		- sin(-0) = -sin(0)
	- R = [cos0 -sin0]/[sin0 cos0], R^-1 = [cos0 sin0]/[-sin0 cos0]
	- 따라서 회전행렬의 역행렬은 별도로 삼각함수를 사용하지 않아도 기존 행렬에 전치연산을 적용하는 방법으로 쉽게 구할 수 있다.
		- R^-1 = R^T

## 2부 콘텐츠 제작 기초
### 6장 아핀 공간: 움직이는 가상세계의 구축
- 행렬 곱으로 이동 기능을 구현하는 새로운 방법을 소개한다. 이 방법은 벡터 공간의 일부에만 적용할 수 있는데, 이동이 가능한 부분 공간을 아핀 공간(Affine space)이라고 부른다.
#### 6.1 이동 변환을 위한 아핀 공간
- 이동 선형 변환은 2 x 2 정방 행렬의 곱셈으로는 구현할 수 없다. 임의의 벡터 (x, y)를 지정한 크기 (a, b)만큼 이동시키는 기능은 다음과 같이 행렬의 덧셈으로 구할 수 있다.
	- [x]/[y] + [a]/[b] = [x+a]/[y+b]
- 하지만 다음의 행렬 곱을 만족하는 정방행렬 A는 존재하지 않는다.
	- A · [x]/[y] = [x+a]/[y+b]
- 그런데 공간의 차원을 하나 더 늘린다면 이를 구현하는 것이 가능하다. 물체를 표현하는데 두 개의 차원을 사용하고, 차원 하나를 더 추가해 선형 변환을 위한 원점과의 연결고리로 활용한다면 선형 변환의 형태로 이동을 구현할 수 있다.
	- 마지막 차원의 값이 1이라는 특정 조건을 가지는 전단 변환을 활용하면 이동 기능을 행렬로 구현할 수 있다. 이를 이동 변환행렬(Translate transformation matrix)이라고 한다.
	- T = [1 0 a]/[0 1 b]/[0 0 1]
	- 주의할 점은 이동에 사용되는 벡터는 언제나 마지막 차원 값이 1이어야 한다는 것이다.
	- 크기 변환행렬과 회전 변환행렬을 3차원으로 늘린 행렬은 다음과 같다.
		- S = [a 0 0]/[0 b 0]/[0 0 1]
		- R = [cos0 -sin0 0]/[sin0 cos0 0]/[0 0 1]
		- 이렇게 한 차원을 높여 설계한 선형 변환을 아핀 변환(Affine transformation)이라고 한다.

#### 6.2 아핀 공간의 구성 요소
- 점
	- 마지막 차원 값이 1인 아핀 공간의 원소를 점(Point)이라고 부른다. 점이 지니는 성질은 행렬 곱을 사용해 이동이 가능하다는 것이다. 가상 공간이 이동하려면 물체는 점으로 구성되어야 한다.
	- 이동 가능한 2차원 아핀 공간과 3차원 아핀 공간의 구성 요소인 점은 다음의 현태를 띤다.
		- 2차원 공간의 점: (x, y, 1)
		- 3차원 공간의 점: (x, y, z, 1)
- 이동 벡터
	- 벡터의 합 연산으로 아핀 공간의 원소인 점을 이동시켰을 때, 행렬 곱의 장점을 유지하기 위해서는 그 결과는 항상 아핀 공간에 닫혀 있어야 한다. 이를 위해서 아핀 공간은 벡터라는 개념을 추가로 제공한다.
	- 벡터는 아핀 공간 내의 이동을 지정하기 위해 사용되는데, 벡터 공간의 원소로 정의한 벡터와 같은 단어지만 다른 용도로 사용된다. 둘을 구분하기 위해 아핀 공간의 벡터를 이동 벡터 또는 변위 벡터(Displacement Vector)라고 한다.
	- 아핀 공간의 점 P1에 이동 벡터 v를 더한 결과는 아핀 공간의 다른 점 P2에 대응 되는데 이를 수식으로 나타내면 다음과 같다.
		- P1 + v = P2
	- 이 수식에서 점 P1을 우변으로 이항하면 이동 벡터를 만들 수 있다.
		- v = P2 - P1
	- 이동 벡터의 마지막 차원 값은 x, y값과 무관하게 항상 0이 된다.
		- (x1 - x2, y1 - y2, 0)
	- 따라서 이동 벡터들이 모이면 마지막 차원 z의 값이 항상 0인 영역을 형성할 것이다.
- 아핀 공간의 성질
	- 점: 물체를 표현하고 위치를 지정하는 데 사용한다. 마지막 차원의 값은 항상 1이다.
	- 이동 벡터: 물체를 움직이는 데 사용한다. 마지막 차원의 값은 항상 0이다.
	- 점과 벡터의 두 요소 사이에는 다음과 같은 연산 규칙이 성립된다. 이때 점과 점을 더하는 수식은 마지막 차원 값이 2가 되어 아핀 공간 영역을 벗어나기 때문에 성립하지 않는다.
		- 점 - 점 = 벡터
		- 점 + 벡터 = 점
		- 벡터 + 벡터 = 벡터
		- 점 + 점 ≠ 점
		- 점과 벡터의 관계는 시각과 시간 개념과 비슷하다 볼 수 있다.(3시 - 2시 = 1시간, 2시 + 2시간 = 4시...)

#### 6.3 아핀 결합
- 아핀 공간을 다룰 때 점과 점을 더한 결과는 사용할 수 없지만 그대로 더하는 것이 아닌 선형 결합의 형태로 점에 스칼라(계수)를 곱해 더한다면, 특정 조건에서 새로운 점을 생성하는 것이 가능해진다.
	- a·P1 + b·P2 = (ax1 + bx2, ay1 + by2, a + b)
	- 두 점의 선형 결합 결과가 언제나 점이 되려면 마지막 차원 값 a + b가 1이 되어야 한다. x, y값과 무관하게 a + b = 1의 조건을 유지한다면 점과 점을 결합해 새로운 점을 만들 수 있다.
	- 동일한 원리로 세 점에 대해서도 다음 수식과 같이 모든 스칼라 a, b, c의 합이 1이면 점의 생성이 가능하다.
	- a·P1 + b·P2 + c·P3 = P4 (s.t.a + b + c = 1) (s.t.는 such that의 약자며 수식이 성립하기 위한 조건을 의미한다.)
	- 이렇게 여러 개의 점을 결합해 새로운 점을 생성하는 수식을 아핀 결합(Affine combination)이라고 한다.
- 두 점의 결합
	- 점에 곱한 두 스칼라의 합이 a + b = 1을 만족해야 하므로 b는 1 - a로 치환 가능하다. 따라서 다음의 수식이 성립된다.
		- a·P1 + (1 - a)·P2 = P'
	- a에 1을 대입하면 점P1이, a에 0을 대입하면 점P2가, a에 0.5를 대입하면 점P1, P2의 중점이 만들어진다.
	- 모든 실수 a를 대입하면 두 점을 이은 양 끝으로 무한히 뻗은 선을 얻게 될 것이다. 이 수식을 직선의 방정식이라고 한다.
		- L(a) = a·P1 + (1 - a)·P2
	- -∞ < a < ∞를 직선(Line), 0 <= a < ∞를 반직선(Ray), 0 <= a <= 1을 선분(Line segment)라고 부른다.
	- 반직선은 한쪽 방향으로만 뻗어나가는 선으로, 게임 제작에서 전방에 물체가 있는지 탐지하기 위해 사용하는 Raycasting에 사용된다. 화면에 도달한 빛의 경로를 추적해 빛의 경로를 시뮬레이션하는 Raytracing 기술에도 활용된다.

#### 6.4 선 그리기 알고리즘
- 벡터를 모니터의 점으로 표현
	- 수학에서 벡터를 표현할 때에는 y축이 위쪽을 향하는 데카르트 좌표계를 사용하지만, 모니터 화면의 좌표계는 y축이 아래쪽을 향하는 방식을 사용한다. 이를 스크린 좌표계(Screen coordinate system)라고 한다.
	- 스크린 좌표계는 실수가 아닌 정수를 사용한다.
	- 스크린 좌표계에 무언가를 표현하기 위해서는 반드시 색상이 함께 지정되어야 한다. 이렇게 좌표와 색상에 대응하는 화면의 구성 요소를 픽셀(Pixel)이라고 한다. 따라서 벡터를 화면의 점으로 최종 표현하기 위해서는 실수로 표현된 벡터 좌표를 정수로 변환한 후 색상을 부여하는 과정을 거쳐야 한다. 이러한 변환 과정을 픽셀화(Rasteriztion)이라고 한다.
- 선 그리기 알고리즘
	- 우리가 점을 찍을 모니터 화면은 정수 좌표로 구성되있는데, 직선의 방정식을 이용해 그리게 되면 하나의 픽셀에 대응되는 다수의 벡터가 생성되기 때문에 비효율 적이다.
	- 브레젠험 알고리즘(Brsenham's algorithm)
		- 1962년도에 발표된 대표적인 방법으로 정수만 사용해 효율적으로 화면에 선분을 그린다.
		- 브레젠험 알고리즘은 화면을 8등분 영역으로 구분한 후 각 영역별로 그려내는 방식을 사용한다
		- 기울기를 이용해 점이 선위에 있는지 아래있는지 확인하는 방식으로 픽셀을 판별
	- 라인 클리핑 알고리즘
		- 브레젠험 알고리즘은 단순하고 빠르지만 이것만으로 선을 그리기에는 충분하지 않다. 브레젠험 알고리즘은 시작지점에서 목표지점에 도달할 때까지 한 픽셀씩 전진하면서 점을 찍기 때문에, 화면을 벗어나는 굉장히 큰 값이 들어오더라도 목표에 도달할 때까지 한 칸씩 전진하면서 계산해야 한다.
		- 따라서 굉장히 긴 선분이 들어와도 화면 영역에 유효한 부분만 잘라주는 알고리즘이 있다면 좋을 것이다. 선분이 가진 성질은 유지하면서 지정된 영역에 맞는 데이터로 재설정하는 작업을 클리핑(Clipping)이라고 한다.
		- 1967년도에 개발된 코헨-서덜랜드 라인 클리핑 알고리즘(Cohen-Sutherland line clipping algorithm)은 구현이 단순하면서 빠르다.
		- 다음과 같이 입력된 선분을 그릴 영역을 화면과 그 바깥 영역을 포함해 총 9개로 설정한다. 각 영역마다 상위 두 비트는 상하 정보를, 하위 두 비트는 좌우 정보를 담아 총 네 자리의 이진수 값으로 고유한 값을 부여한다.
			- 1001 1000 1010
			- 0001 0000 0010
			- 0101 0100 0110
			- 가운데 0000은 화면 영역을 의미한다. 따라서 선분의 시작점과 끝점이 모두 0000에 있다면 클리핑이 없어도 된다. 선분이 0000에 들어오지 않는다면 선을 그릴 필요가 없다.
		- 비트연산을 통해 어떤 지점을 거치는지 파악하고, 클리핑을 진행한다.

### 7장 내적: 벡터 공간의 분석과 응용
#### 7.1 벡터의 내적
- 벡터의 내적(Dot product)은 같은 차원의 두 벡터가 주어졌을 때, 벡터를 구성하는 각 성분을 곱한 후 이들을 더해 스칼라를 만들어내는 연산이다.
	- u = (a, b)
	- v = (c, d)
	- u·v = a·c + b·d
- 내적의 성질
	- 내적은 교환법칙이 성립한다.
	- 결합법칙이 성립하지 않는다.
	- 덧셈에 대한 분배법칙이 성립한다.
	- 같은 벡터를 내적하면 벡터의 크기를 제곱한 결과가 나온다.
		- (x, y)·(x, y) = x^2 + y^2
		- v·v = v^2
- 내적과 삼각함수와의 관계
	- 벡터의 내적은 두 벡터의 사잇각에 대한 cos 함수와 비례하는 특징을 가진다.
	- u·v = |u||v|cos0
	- 이러한 내적의 성질은 덧셈과 곱셈만 사용해 cos 함수 값을 빠르게 계산할 수 있어 유용하게 활용된다.
	- 또한 위 식에서 영벡터가 아닌 경우, 내적 값이 0이 되기 위한 조건은 cos 함수 값이 0이 되는 경우 뿐인데, 이는 두 벡터의 사잇각이 90도 혹은 270(-90)도인 경우이다.
	- 따라서 두 벡터의 내적이 0이면 두 벡터는 직교한다고 결론내릴 수 있다.

#### 7.2 시야 판별
- 앞뒤 판별
	- 내적의 부호를 통해 목표물이 캐릭터의 앞에 있는지, 뒤에 있는지 구분할 수 있다.
	- 캐릭터의 시선벡터 f와 목표물로 향하는 벡터 v의 내적 결과에 따라 앞뒤 여부를 판단할 수 있다.
		- f·v > 0 : 캐릭터 앞에 목표물이 있다.
		- f·v < 0 : 캐릭터 뒤에 목표물이 있다.
		- f·v = 0 : 캐릭터 바로 옆에 목표물이 있다.
- 시야 판별
	- 캐릭터에 부여한 시야각이 β라면 양쪽으로 균등하게 β/2의 시야각이 설정된다.
	- 앞뒤 판별 문제와 동일하게 벡터 f, v를 만든 후 사잇각을 α로 설정한다.
	- 사잇각 α가 β/2보다 작거나 같은지 비교하는 문제가 된다. (작거나 같다면 시야각 안에 들어온다)
	- 판별 과정
		- cos(β/2)를 미리 계산해둔다.
		- 캐릭터의 시선 벡터를 구하고 이의 크기를 1로 정규화 시킨다. 이를 단위벡터 f라고 하자
		- 캐릭터에서 목표물로 향하는 벡터도 정규화 시킨다. 이를 단위벡터 v라고 하자
		- 내적 f·v의 계산 결과는 cosα가 된다. 이를 앞서 계산해 둔 cos(β/2)값과 비교한다.
		- f·v >= cos(β/2) 목표물이 시야 범위 안에 있음
		- f·v < cos(β/2) 목표물이 시야 범위 밖에 있음
	- atan2함수를 활용해 이루는 각 α를 구한 후 β/2값과 비교해도 동일한 결과를 얻을 수 있지만, 내적으로 계산하는 방식이 더 효율적이다.

#### 7.3 조명 효과의 구현
- 램버트 반사 모델
	- 계산량이 적어 속도가 빠르지만 그럴듯한 조명 효과를 줄 수 있어 실시간 조명 구현이 필요한 게임에 널리 사용된다.
	- 빛을 받아 표면에서 반사되는 빛의 세기는 두 벡터가 만드는 사잇각의 cos 함수에 비례한다는 것이 램버트 반사 모델의 주요 내용이다.

#### 7.4 투영 벡터
- 벡터 내적은 어떤 벡터를 다른 벡터에 직교 투영하는 용도로도 사용된다.
- 수식으로 표현하면 다음과 같다. (벡터 v의 크기가 1이면)
	- v' = (u·v)·v


### 8장 삼각형: 물체를 구성하는 가장 작은 단위
#### 8.1 세점의 결합
- 세 점 P1, P2, P3를 결합하는 경우 스칼라는 3개로 늘어나는데 세 스칼라의 합은 1이 되어야 하므로 아핀 결합식은 다음과 같이 전개된다.
	- P' = s·P1 + t·P2 + (1-s-t)·P3
	- (P' - P3) = s(P1 - P3) + t(P2 - P3)
	- w = s·u t·v
- 스칼라 s와 t의 값을 [0, 1] 범위로 고정시키면 해당 영역은 삼각형이 된다.
- 이렇게 아핀 결합에서 모든 스칼라 값을 [0, 1] 범위로 한정한 결합을 컨벡스 결합(Convex combination)이라고 부른다.
- 4개의 점을 결합한다면? 삼각뿔 영역이 형성된다.

#### 8.2 메시
- 3차원 공간의 입체적인 물체 또한 삼각형을 이어붙이면 표현이 가능하다. 그래서 삼각형을 중심으로 물체에 관련된 정보를 기록한 데이터를 메시(Mesh)라고 한다.
- 메시는 삼각형을 이루는 각 점의 위치를 가지고 있어야 한다. 그런데 위치 정보만 담지 않고, 물체를 표현하는 데 활용할 수 있는 색상이나 방향과 같은 다양한 부가 정보도 담아 함께 제공한다. 이렇게 위치 정보와 부가 정보를 묶은 특별한 점을 정점(Vertex)라고 한다.
- 즉 메시는 정점들이 모인 데이터이고, 컴퓨터에서 메시를 빨리 읽기 위해 메모리에 정점 정보를 일렬로 나열하는 배열의 형태로 관리한다. 이를 정점 버퍼(Vertex buffer)라고 한다.
- 정점 버퍼의 정보만으로는 어떤 세 정점이 모여 삼각형을 구성하는지 알 수 없기 때문에, 인덱스만 기록한 배열 또한 별도로 만들어 관리한다. 이를 인덱스 버퍼(Index buffer)라고 한다.
	- 인덱스 정보는 삼각형의 수만큼 필요하기 때문에 인덱스 버퍼의 크기는 항상 3의 배수다.
- 삼각형을 하나씩 표현해나가면 메시를 형상화할 수 있다. 삼각형의 외곽선만 그려 메시를 표현하는 방법을 와이어프레임(Wireframe)이라고 한다.

#### 8.3 무게 중심 좌표
- 무게 중심 좌표를 구해 해당 점이 삼각형 내부에 있는지 외부에 있는지 판별할 수 있다.

#### 8.4 텍스처 매핑
- 무게 중심 좌표는 메시에 이미지를 입히는 용도로 활용할 수도 있다.
- 메시에 이미지를 입히기 위해 변환된 데이터를 텍스처(Texture)라고 하며, 메시에 이미지를 입히는 작업을 텍스처 매핑(Texture mapping)이라고 한다.
- 우리가 저장한 이미지는 가로와 세로의 픽셀 수에 따른 고유한 해상도를 가진다. 하지만 이미지를 메시에 입히기 위해 텍스처로 변환하면 관리 방식을 통일하기 위해 이미지의 원본 해상도에 관계없이 텍스처의 가로, 세로 크기는 1로 정규화된다.
- 따라서 렌더링 과정에서 텍스처를 사용할 때에는 [0, 1] 범위로 구성된 2차원 좌표계를 사용하고, 이를 UV 좌표계라고 한다. (가로 U, 세로 V)
- 텍스처 매핑의 구현
	- 이미지의 좌표와 정점 버퍼의 좌표를 하나씩 매핑시킨다.

### 9장 게임 엔진: 콘텐츠를 만드는 기술
- CK소프트렌더러의 워크 플로우

## 3부 3차원 콘텐츠 제작
### 10장 3차원 공간: 입체 공간의 생성
